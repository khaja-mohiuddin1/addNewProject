/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/source-map-js";
exports.ids = ["vendor-chunks/source-map-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/source-map-js/lib/array-set.js":
/*!*****************************************************!*\
  !*** ./node_modules/source-map-js/lib/array-set.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/source-map-js/lib/util.js\");\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */ function ArraySet() {\n    this._array = [];\n    this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n/**\n * Static method for creating ArraySet instances from an existing array.\n */ ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n    var set = new ArraySet();\n    for(var i = 0, len = aArray.length; i < len; i++){\n        set.add(aArray[i], aAllowDuplicates);\n    }\n    return set;\n};\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */ ArraySet.prototype.size = function ArraySet_size() {\n    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */ ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n    var idx = this._array.length;\n    if (!isDuplicate || aAllowDuplicates) {\n        this._array.push(aStr);\n    }\n    if (!isDuplicate) {\n        if (hasNativeMap) {\n            this._set.set(aStr, idx);\n        } else {\n            this._set[sStr] = idx;\n        }\n    }\n};\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */ ArraySet.prototype.has = function ArraySet_has(aStr) {\n    if (hasNativeMap) {\n        return this._set.has(aStr);\n    } else {\n        var sStr = util.toSetString(aStr);\n        return has.call(this._set, sStr);\n    }\n};\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */ ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n    if (hasNativeMap) {\n        var idx = this._set.get(aStr);\n        if (idx >= 0) {\n            return idx;\n        }\n    } else {\n        var sStr = util.toSetString(aStr);\n        if (has.call(this._set, sStr)) {\n            return this._set[sStr];\n        }\n    }\n    throw new Error('\"' + aStr + '\" is not in the set.');\n};\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */ ArraySet.prototype.at = function ArraySet_at(aIdx) {\n    if (aIdx >= 0 && aIdx < this._array.length) {\n        return this._array[aIdx];\n    }\n    throw new Error(\"No element indexed by \" + aIdx);\n};\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */ ArraySet.prototype.toArray = function ArraySet_toArray() {\n    return this._array.slice();\n};\nexports.ArraySet = ArraySet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1qcy9saWIvYXJyYXktc2V0LmpzIiwibWFwcGluZ3MiOiJBQUFBLHlDQUF5QyxHQUN6Qzs7OztDQUlDLEdBRUQsSUFBSUEsT0FBT0MsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUMsTUFBTUMsT0FBT0MsU0FBUyxDQUFDQyxjQUFjO0FBQ3pDLElBQUlDLGVBQWUsT0FBT0MsUUFBUTtBQUVsQzs7Ozs7Q0FLQyxHQUNELFNBQVNDO0lBQ1AsSUFBSSxDQUFDQyxNQUFNLEdBQUcsRUFBRTtJQUNoQixJQUFJLENBQUNDLElBQUksR0FBR0osZUFBZSxJQUFJQyxRQUFRSixPQUFPUSxNQUFNLENBQUM7QUFDdkQ7QUFFQTs7Q0FFQyxHQUNESCxTQUFTSSxTQUFTLEdBQUcsU0FBU0MsbUJBQW1CQyxNQUFNLEVBQUVDLGdCQUFnQjtJQUN2RSxJQUFJQyxNQUFNLElBQUlSO0lBQ2QsSUFBSyxJQUFJUyxJQUFJLEdBQUdDLE1BQU1KLE9BQU9LLE1BQU0sRUFBRUYsSUFBSUMsS0FBS0QsSUFBSztRQUNqREQsSUFBSUksR0FBRyxDQUFDTixNQUFNLENBQUNHLEVBQUUsRUFBRUY7SUFDckI7SUFDQSxPQUFPQztBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDRFIsU0FBU0osU0FBUyxDQUFDaUIsSUFBSSxHQUFHLFNBQVNDO0lBQ2pDLE9BQU9oQixlQUFlLElBQUksQ0FBQ0ksSUFBSSxDQUFDVyxJQUFJLEdBQUdsQixPQUFPb0IsbUJBQW1CLENBQUMsSUFBSSxDQUFDYixJQUFJLEVBQUVTLE1BQU07QUFDckY7QUFFQTs7OztDQUlDLEdBQ0RYLFNBQVNKLFNBQVMsQ0FBQ2dCLEdBQUcsR0FBRyxTQUFTSSxhQUFhQyxJQUFJLEVBQUVWLGdCQUFnQjtJQUNuRSxJQUFJVyxPQUFPcEIsZUFBZW1CLE9BQU96QixLQUFLMkIsV0FBVyxDQUFDRjtJQUNsRCxJQUFJRyxjQUFjdEIsZUFBZSxJQUFJLENBQUNKLEdBQUcsQ0FBQ3VCLFFBQVF2QixJQUFJMkIsSUFBSSxDQUFDLElBQUksQ0FBQ25CLElBQUksRUFBRWdCO0lBQ3RFLElBQUlJLE1BQU0sSUFBSSxDQUFDckIsTUFBTSxDQUFDVSxNQUFNO0lBQzVCLElBQUksQ0FBQ1MsZUFBZWIsa0JBQWtCO1FBQ3BDLElBQUksQ0FBQ04sTUFBTSxDQUFDc0IsSUFBSSxDQUFDTjtJQUNuQjtJQUNBLElBQUksQ0FBQ0csYUFBYTtRQUNoQixJQUFJdEIsY0FBYztZQUNoQixJQUFJLENBQUNJLElBQUksQ0FBQ00sR0FBRyxDQUFDUyxNQUFNSztRQUN0QixPQUFPO1lBQ0wsSUFBSSxDQUFDcEIsSUFBSSxDQUFDZ0IsS0FBSyxHQUFHSTtRQUNwQjtJQUNGO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0R0QixTQUFTSixTQUFTLENBQUNGLEdBQUcsR0FBRyxTQUFTOEIsYUFBYVAsSUFBSTtJQUNqRCxJQUFJbkIsY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQ0ksSUFBSSxDQUFDUixHQUFHLENBQUN1QjtJQUN2QixPQUFPO1FBQ0wsSUFBSUMsT0FBTzFCLEtBQUsyQixXQUFXLENBQUNGO1FBQzVCLE9BQU92QixJQUFJMkIsSUFBSSxDQUFDLElBQUksQ0FBQ25CLElBQUksRUFBRWdCO0lBQzdCO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0RsQixTQUFTSixTQUFTLENBQUM2QixPQUFPLEdBQUcsU0FBU0MsaUJBQWlCVCxJQUFJO0lBQ3pELElBQUluQixjQUFjO1FBQ2hCLElBQUl3QixNQUFNLElBQUksQ0FBQ3BCLElBQUksQ0FBQ3lCLEdBQUcsQ0FBQ1Y7UUFDeEIsSUFBSUssT0FBTyxHQUFHO1lBQ1YsT0FBT0E7UUFDWDtJQUNGLE9BQU87UUFDTCxJQUFJSixPQUFPMUIsS0FBSzJCLFdBQVcsQ0FBQ0Y7UUFDNUIsSUFBSXZCLElBQUkyQixJQUFJLENBQUMsSUFBSSxDQUFDbkIsSUFBSSxFQUFFZ0IsT0FBTztZQUM3QixPQUFPLElBQUksQ0FBQ2hCLElBQUksQ0FBQ2dCLEtBQUs7UUFDeEI7SUFDRjtJQUVBLE1BQU0sSUFBSVUsTUFBTSxNQUFNWCxPQUFPO0FBQy9CO0FBRUE7Ozs7Q0FJQyxHQUNEakIsU0FBU0osU0FBUyxDQUFDaUMsRUFBRSxHQUFHLFNBQVNDLFlBQVlDLElBQUk7SUFDL0MsSUFBSUEsUUFBUSxLQUFLQSxPQUFPLElBQUksQ0FBQzlCLE1BQU0sQ0FBQ1UsTUFBTSxFQUFFO1FBQzFDLE9BQU8sSUFBSSxDQUFDVixNQUFNLENBQUM4QixLQUFLO0lBQzFCO0lBQ0EsTUFBTSxJQUFJSCxNQUFNLDJCQUEyQkc7QUFDN0M7QUFFQTs7OztDQUlDLEdBQ0QvQixTQUFTSixTQUFTLENBQUNvQyxPQUFPLEdBQUcsU0FBU0M7SUFDcEMsT0FBTyxJQUFJLENBQUNoQyxNQUFNLENBQUNpQyxLQUFLO0FBQzFCO0FBRUFDLGdCQUFnQixHQUFHbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b3JrZmxvdy8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwLWpzL2xpYi9hcnJheS1zZXQuanM/M2RhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBoYXNOYXRpdmVNYXAgPSB0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiO1xuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICogbWVtYmVyIGlzIE8oMSksIHRlc3RpbmcgZm9yIG1lbWJlcnNoaXAgaXMgTygxKSwgYW5kIGZpbmRpbmcgdGhlIGluZGV4IG9mIGFuXG4gKiBlbGVtZW50IGlzIE8oMSkuIFJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHNldCBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5XG4gKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gKi9cbmZ1bmN0aW9uIEFycmF5U2V0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zZXQgPSBoYXNOYXRpdmVNYXAgPyBuZXcgTWFwKCkgOiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIFN0YXRpYyBtZXRob2QgZm9yIGNyZWF0aW5nIEFycmF5U2V0IGluc3RhbmNlcyBmcm9tIGFuIGV4aXN0aW5nIGFycmF5LlxuICovXG5BcnJheVNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF9mcm9tQXJyYXkoYUFycmF5LCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzZXQgPSBuZXcgQXJyYXlTZXQoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHNldC5hZGQoYUFycmF5W2ldLCBhQWxsb3dEdXBsaWNhdGVzKTtcbiAgfVxuICByZXR1cm4gc2V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gaG93IG1hbnkgdW5pcXVlIGl0ZW1zIGFyZSBpbiB0aGlzIEFycmF5U2V0LiBJZiBkdXBsaWNhdGVzIGhhdmUgYmVlblxuICogYWRkZWQsIHRoYW4gdGhvc2UgZG8gbm90IGNvdW50IHRvd2FyZHMgdGhlIHNpemUuXG4gKlxuICogQHJldHVybnMgTnVtYmVyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gQXJyYXlTZXRfc2l6ZSgpIHtcbiAgcmV0dXJuIGhhc05hdGl2ZU1hcCA/IHRoaXMuX3NldC5zaXplIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fc2V0KS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHRoaXMgc2V0LlxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gQXJyYXlTZXRfYWRkKGFTdHIsIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHNTdHIgPSBoYXNOYXRpdmVNYXAgPyBhU3RyIDogdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgdmFyIGlzRHVwbGljYXRlID0gaGFzTmF0aXZlTWFwID8gdGhpcy5oYXMoYVN0cikgOiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB2YXIgaWR4ID0gdGhpcy5fYXJyYXkubGVuZ3RoO1xuICBpZiAoIWlzRHVwbGljYXRlIHx8IGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFTdHIpO1xuICB9XG4gIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgICB0aGlzLl9zZXQuc2V0KGFTdHIsIGlkeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldFtzU3RyXSA9IGlkeDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIHN0cmluZyBhIG1lbWJlciBvZiB0aGlzIHNldD9cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIEFycmF5U2V0X2hhcyhhU3RyKSB7XG4gIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0LmhhcyhhU3RyKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gICAgcmV0dXJuIGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG4gIH1cbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgYXJyYXk/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5fc2V0LmdldChhU3RyKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0W3NTdHJdO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXg/XG4gKlxuICogQHBhcmFtIE51bWJlciBhSWR4XG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpIHtcbiAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5W2FJZHhdO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcgKyBhSWR4KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzZXQgKHdoaWNoIGhhcyB0aGUgcHJvcGVyIGluZGljZXNcbiAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gKiBmb3Igc3RvcmluZyB0aGUgbWVtYmVycyBzbyB0aGF0IG5vIG9uZSBjYW4gbWVzcyB3aXRoIGludGVybmFsIHN0YXRlLlxuICovXG5BcnJheVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKSB7XG4gIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xufTtcblxuZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xuIl0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwiaGFzIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJoYXNOYXRpdmVNYXAiLCJNYXAiLCJBcnJheVNldCIsIl9hcnJheSIsIl9zZXQiLCJjcmVhdGUiLCJmcm9tQXJyYXkiLCJBcnJheVNldF9mcm9tQXJyYXkiLCJhQXJyYXkiLCJhQWxsb3dEdXBsaWNhdGVzIiwic2V0IiwiaSIsImxlbiIsImxlbmd0aCIsImFkZCIsInNpemUiLCJBcnJheVNldF9zaXplIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIkFycmF5U2V0X2FkZCIsImFTdHIiLCJzU3RyIiwidG9TZXRTdHJpbmciLCJpc0R1cGxpY2F0ZSIsImNhbGwiLCJpZHgiLCJwdXNoIiwiQXJyYXlTZXRfaGFzIiwiaW5kZXhPZiIsIkFycmF5U2V0X2luZGV4T2YiLCJnZXQiLCJFcnJvciIsImF0IiwiQXJyYXlTZXRfYXQiLCJhSWR4IiwidG9BcnJheSIsIkFycmF5U2V0X3RvQXJyYXkiLCJzbGljZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/source-map-js/lib/array-set.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/source-map-js/lib/base64-vlq.js":
/*!******************************************************!*\
  !*** ./node_modules/source-map-js/lib/base64-vlq.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */ var base64 = __webpack_require__(/*! ./base64 */ \"(ssr)/./node_modules/source-map-js/lib/base64.js\");\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\nvar VLQ_BASE_SHIFT = 5;\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */ function toVLQSigned(aValue) {\n    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;\n}\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */ function fromVLQSigned(aValue) {\n    var isNegative = (aValue & 1) === 1;\n    var shifted = aValue >> 1;\n    return isNegative ? -shifted : shifted;\n}\n/**\n * Returns the base 64 VLQ encoded value.\n */ exports.encode = function base64VLQ_encode(aValue) {\n    var encoded = \"\";\n    var digit;\n    var vlq = toVLQSigned(aValue);\n    do {\n        digit = vlq & VLQ_BASE_MASK;\n        vlq >>>= VLQ_BASE_SHIFT;\n        if (vlq > 0) {\n            // There are still more digits in this value, so we must make sure the\n            // continuation bit is marked.\n            digit |= VLQ_CONTINUATION_BIT;\n        }\n        encoded += base64.encode(digit);\n    }while (vlq > 0);\n    return encoded;\n};\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */ exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n    var strLen = aStr.length;\n    var result = 0;\n    var shift = 0;\n    var continuation, digit;\n    do {\n        if (aIndex >= strLen) {\n            throw new Error(\"Expected more digits in base 64 VLQ value.\");\n        }\n        digit = base64.decode(aStr.charCodeAt(aIndex++));\n        if (digit === -1) {\n            throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n        }\n        continuation = !!(digit & VLQ_CONTINUATION_BIT);\n        digit &= VLQ_BASE_MASK;\n        result = result + (digit << shift);\n        shift += VLQ_BASE_SHIFT;\n    }while (continuation);\n    aOutParam.value = fromVLQSigned(result);\n    aOutParam.rest = aIndex;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1qcy9saWIvYmFzZTY0LXZscS5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5Q0FBeUMsR0FDekM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQ0MsR0FFRCxJQUFJQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUVyQiw4RUFBOEU7QUFDOUUsOEVBQThFO0FBQzlFLGtFQUFrRTtBQUNsRSx5RUFBeUU7QUFDekUsNkNBQTZDO0FBQzdDLEVBQUU7QUFDRixpQkFBaUI7QUFDakIsY0FBYztBQUNkLFdBQVc7QUFDWCxXQUFXO0FBQ1gsV0FBVztBQUVYLElBQUlDLGlCQUFpQjtBQUVyQixpQkFBaUI7QUFDakIsSUFBSUMsV0FBVyxLQUFLRDtBQUVwQixpQkFBaUI7QUFDakIsSUFBSUUsZ0JBQWdCRCxXQUFXO0FBRS9CLGlCQUFpQjtBQUNqQixJQUFJRSx1QkFBdUJGO0FBRTNCOzs7OztDQUtDLEdBQ0QsU0FBU0csWUFBWUMsTUFBTTtJQUN6QixPQUFPQSxTQUFTLElBQ1osQ0FBQyxDQUFFQSxVQUFXLEtBQUssSUFDbkIsQ0FBQ0EsVUFBVSxLQUFLO0FBQ3RCO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTQyxjQUFjRCxNQUFNO0lBQzNCLElBQUlFLGFBQWEsQ0FBQ0YsU0FBUyxPQUFPO0lBQ2xDLElBQUlHLFVBQVVILFVBQVU7SUFDeEIsT0FBT0UsYUFDSCxDQUFDQyxVQUNEQTtBQUNOO0FBRUE7O0NBRUMsR0FDREMsY0FBYyxHQUFHLFNBQVNFLGlCQUFpQk4sTUFBTTtJQUMvQyxJQUFJTyxVQUFVO0lBQ2QsSUFBSUM7SUFFSixJQUFJQyxNQUFNVixZQUFZQztJQUV0QixHQUFHO1FBQ0RRLFFBQVFDLE1BQU1aO1FBQ2RZLFNBQVNkO1FBQ1QsSUFBSWMsTUFBTSxHQUFHO1lBQ1gsc0VBQXNFO1lBQ3RFLDhCQUE4QjtZQUM5QkQsU0FBU1Y7UUFDWDtRQUNBUyxXQUFXZCxPQUFPWSxNQUFNLENBQUNHO0lBQzNCLFFBQVNDLE1BQU0sR0FBRztJQUVsQixPQUFPRjtBQUNUO0FBRUE7OztDQUdDLEdBQ0RILGNBQWMsR0FBRyxTQUFTTyxpQkFBaUJDLElBQUksRUFBRUMsTUFBTSxFQUFFQyxTQUFTO0lBQ2hFLElBQUlDLFNBQVNILEtBQUtJLE1BQU07SUFDeEIsSUFBSUMsU0FBUztJQUNiLElBQUlDLFFBQVE7SUFDWixJQUFJQyxjQUFjWDtJQUVsQixHQUFHO1FBQ0QsSUFBSUssVUFBVUUsUUFBUTtZQUNwQixNQUFNLElBQUlLLE1BQU07UUFDbEI7UUFFQVosUUFBUWYsT0FBT2lCLE1BQU0sQ0FBQ0UsS0FBS1MsVUFBVSxDQUFDUjtRQUN0QyxJQUFJTCxVQUFVLENBQUMsR0FBRztZQUNoQixNQUFNLElBQUlZLE1BQU0sMkJBQTJCUixLQUFLVSxNQUFNLENBQUNULFNBQVM7UUFDbEU7UUFFQU0sZUFBZSxDQUFDLENBQUVYLENBQUFBLFFBQVFWLG9CQUFtQjtRQUM3Q1UsU0FBU1g7UUFDVG9CLFNBQVNBLFNBQVVULENBQUFBLFNBQVNVLEtBQUk7UUFDaENBLFNBQVN2QjtJQUNYLFFBQVN3QixjQUFjO0lBRXZCTCxVQUFVUyxLQUFLLEdBQUd0QixjQUFjZ0I7SUFDaENILFVBQVVVLElBQUksR0FBR1g7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b3JrZmxvdy8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwLWpzL2xpYi9iYXNlNjQtdmxxLmpzPzg0ZDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiBCYXNlZCBvbiB0aGUgQmFzZSA2NCBWTFEgaW1wbGVtZW50YXRpb24gaW4gQ2xvc3VyZSBDb21waWxlcjpcbiAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2xvc3VyZS1jb21waWxlci9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2RlYnVnZ2luZy9zb3VyY2VtYXAvQmFzZTY0VkxRLmphdmFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBUaGUgQ2xvc3VyZSBDb21waWxlciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuICogICAgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcblxuLy8gQSBzaW5nbGUgYmFzZSA2NCBkaWdpdCBjYW4gY29udGFpbiA2IGJpdHMgb2YgZGF0YS4gRm9yIHRoZSBiYXNlIDY0IHZhcmlhYmxlXG4vLyBsZW5ndGggcXVhbnRpdGllcyB3ZSB1c2UgaW4gdGhlIHNvdXJjZSBtYXAgc3BlYywgdGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbixcbi8vIHRoZSBuZXh0IGZvdXIgYml0cyBhcmUgdGhlIGFjdHVhbCB2YWx1ZSwgYW5kIHRoZSA2dGggYml0IGlzIHRoZVxuLy8gY29udGludWF0aW9uIGJpdC4gVGhlIGNvbnRpbnVhdGlvbiBiaXQgdGVsbHMgdXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZVxuLy8gZGlnaXRzIGluIHRoaXMgdmFsdWUgZm9sbG93aW5nIHRoaXMgZGlnaXQuXG4vL1xuLy8gICBDb250aW51YXRpb25cbi8vICAgfCAgICBTaWduXG4vLyAgIHwgICAgfFxuLy8gICBWICAgIFZcbi8vICAgMTAxMDExXG5cbnZhciBWTFFfQkFTRV9TSElGVCA9IDU7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0JBU0UgPSAxIDw8IFZMUV9CQVNFX1NISUZUO1xuXG4vLyBiaW5hcnk6IDAxMTExMVxudmFyIFZMUV9CQVNFX01BU0sgPSBWTFFfQkFTRSAtIDE7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0NPTlRJTlVBVElPTl9CSVQgPSBWTFFfQkFTRTtcblxuLyoqXG4gKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAxIGJlY29tZXMgMiAoMTAgYmluYXJ5KSwgLTEgYmVjb21lcyAzICgxMSBiaW5hcnkpXG4gKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxuICovXG5mdW5jdGlvbiB0b1ZMUVNpZ25lZChhVmFsdWUpIHtcbiAgcmV0dXJuIGFWYWx1ZSA8IDBcbiAgICA/ICgoLWFWYWx1ZSkgPDwgMSkgKyAxXG4gICAgOiAoYVZhbHVlIDw8IDEpICsgMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0byBhIHR3by1jb21wbGVtZW50IHZhbHVlIGZyb20gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAyICgxMCBiaW5hcnkpIGJlY29tZXMgMSwgMyAoMTEgYmluYXJ5KSBiZWNvbWVzIC0xXG4gKiAgIDQgKDEwMCBiaW5hcnkpIGJlY29tZXMgMiwgNSAoMTAxIGJpbmFyeSkgYmVjb21lcyAtMlxuICovXG5mdW5jdGlvbiBmcm9tVkxRU2lnbmVkKGFWYWx1ZSkge1xuICB2YXIgaXNOZWdhdGl2ZSA9IChhVmFsdWUgJiAxKSA9PT0gMTtcbiAgdmFyIHNoaWZ0ZWQgPSBhVmFsdWUgPj4gMTtcbiAgcmV0dXJuIGlzTmVnYXRpdmVcbiAgICA/IC1zaGlmdGVkXG4gICAgOiBzaGlmdGVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgNjQgVkxRIGVuY29kZWQgdmFsdWUuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2VuY29kZShhVmFsdWUpIHtcbiAgdmFyIGVuY29kZWQgPSBcIlwiO1xuICB2YXIgZGlnaXQ7XG5cbiAgdmFyIHZscSA9IHRvVkxRU2lnbmVkKGFWYWx1ZSk7XG5cbiAgZG8ge1xuICAgIGRpZ2l0ID0gdmxxICYgVkxRX0JBU0VfTUFTSztcbiAgICB2bHEgPj4+PSBWTFFfQkFTRV9TSElGVDtcbiAgICBpZiAodmxxID4gMCkge1xuICAgICAgLy8gVGhlcmUgYXJlIHN0aWxsIG1vcmUgZGlnaXRzIGluIHRoaXMgdmFsdWUsIHNvIHdlIG11c3QgbWFrZSBzdXJlIHRoZVxuICAgICAgLy8gY29udGludWF0aW9uIGJpdCBpcyBtYXJrZWQuXG4gICAgICBkaWdpdCB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVDtcbiAgICB9XG4gICAgZW5jb2RlZCArPSBiYXNlNjQuZW5jb2RlKGRpZ2l0KTtcbiAgfSB3aGlsZSAodmxxID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIG5leHQgYmFzZSA2NCBWTFEgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIHRoZVxuICogdmFsdWUgYW5kIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgdmlhIHRoZSBvdXQgcGFyYW1ldGVyLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9kZWNvZGUoYVN0ciwgYUluZGV4LCBhT3V0UGFyYW0pIHtcbiAgdmFyIHN0ckxlbiA9IGFTdHIubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gMDtcbiAgdmFyIHNoaWZ0ID0gMDtcbiAgdmFyIGNvbnRpbnVhdGlvbiwgZGlnaXQ7XG5cbiAgZG8ge1xuICAgIGlmIChhSW5kZXggPj0gc3RyTGVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cIik7XG4gICAgfVxuXG4gICAgZGlnaXQgPSBiYXNlNjQuZGVjb2RlKGFTdHIuY2hhckNvZGVBdChhSW5kZXgrKykpO1xuICAgIGlmIChkaWdpdCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGRpZ2l0OiBcIiArIGFTdHIuY2hhckF0KGFJbmRleCAtIDEpKTtcbiAgICB9XG5cbiAgICBjb250aW51YXRpb24gPSAhIShkaWdpdCAmIFZMUV9DT05USU5VQVRJT05fQklUKTtcbiAgICBkaWdpdCAmPSBWTFFfQkFTRV9NQVNLO1xuICAgIHJlc3VsdCA9IHJlc3VsdCArIChkaWdpdCA8PCBzaGlmdCk7XG4gICAgc2hpZnQgKz0gVkxRX0JBU0VfU0hJRlQ7XG4gIH0gd2hpbGUgKGNvbnRpbnVhdGlvbik7XG5cbiAgYU91dFBhcmFtLnZhbHVlID0gZnJvbVZMUVNpZ25lZChyZXN1bHQpO1xuICBhT3V0UGFyYW0ucmVzdCA9IGFJbmRleDtcbn07XG4iXSwibmFtZXMiOlsiYmFzZTY0IiwicmVxdWlyZSIsIlZMUV9CQVNFX1NISUZUIiwiVkxRX0JBU0UiLCJWTFFfQkFTRV9NQVNLIiwiVkxRX0NPTlRJTlVBVElPTl9CSVQiLCJ0b1ZMUVNpZ25lZCIsImFWYWx1ZSIsImZyb21WTFFTaWduZWQiLCJpc05lZ2F0aXZlIiwic2hpZnRlZCIsImV4cG9ydHMiLCJlbmNvZGUiLCJiYXNlNjRWTFFfZW5jb2RlIiwiZW5jb2RlZCIsImRpZ2l0IiwidmxxIiwiZGVjb2RlIiwiYmFzZTY0VkxRX2RlY29kZSIsImFTdHIiLCJhSW5kZXgiLCJhT3V0UGFyYW0iLCJzdHJMZW4iLCJsZW5ndGgiLCJyZXN1bHQiLCJzaGlmdCIsImNvbnRpbnVhdGlvbiIsIkVycm9yIiwiY2hhckNvZGVBdCIsImNoYXJBdCIsInZhbHVlIiwicmVzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/source-map-js/lib/base64-vlq.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/source-map-js/lib/base64.js":
/*!**************************************************!*\
  !*** ./node_modules/source-map-js/lib/base64.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var intToCharMap = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */ exports.encode = function(number) {\n    if (0 <= number && number < intToCharMap.length) {\n        return intToCharMap[number];\n    }\n    throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */ exports.decode = function(charCode) {\n    var bigA = 65; // 'A'\n    var bigZ = 90; // 'Z'\n    var littleA = 97; // 'a'\n    var littleZ = 122; // 'z'\n    var zero = 48; // '0'\n    var nine = 57; // '9'\n    var plus = 43; // '+'\n    var slash = 47; // '/'\n    var littleOffset = 26;\n    var numberOffset = 52;\n    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n    if (bigA <= charCode && charCode <= bigZ) {\n        return charCode - bigA;\n    }\n    // 26 - 51: abcdefghijklmnopqrstuvwxyz\n    if (littleA <= charCode && charCode <= littleZ) {\n        return charCode - littleA + littleOffset;\n    }\n    // 52 - 61: 0123456789\n    if (zero <= charCode && charCode <= nine) {\n        return charCode - zero + numberOffset;\n    }\n    // 62: +\n    if (charCode == plus) {\n        return 62;\n    }\n    // 63: /\n    if (charCode == slash) {\n        return 63;\n    }\n    // Invalid base64 digit.\n    return -1;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1qcy9saWIvYmFzZTY0LmpzIiwibWFwcGluZ3MiOiJBQUFBLHlDQUF5QyxHQUN6Qzs7OztDQUlDLEdBRUQsSUFBSUEsZUFBZSxtRUFBbUVDLEtBQUssQ0FBQztBQUU1Rjs7Q0FFQyxHQUNEQyxjQUFjLEdBQUcsU0FBVUUsTUFBTTtJQUMvQixJQUFJLEtBQUtBLFVBQVVBLFNBQVNKLGFBQWFLLE1BQU0sRUFBRTtRQUMvQyxPQUFPTCxZQUFZLENBQUNJLE9BQU87SUFDN0I7SUFDQSxNQUFNLElBQUlFLFVBQVUsK0JBQStCRjtBQUNyRDtBQUVBOzs7Q0FHQyxHQUNERixjQUFjLEdBQUcsU0FBVU0sUUFBUTtJQUNqQyxJQUFJQyxPQUFPLElBQVEsTUFBTTtJQUN6QixJQUFJQyxPQUFPLElBQVEsTUFBTTtJQUV6QixJQUFJQyxVQUFVLElBQUssTUFBTTtJQUN6QixJQUFJQyxVQUFVLEtBQUssTUFBTTtJQUV6QixJQUFJQyxPQUFPLElBQVEsTUFBTTtJQUN6QixJQUFJQyxPQUFPLElBQVEsTUFBTTtJQUV6QixJQUFJQyxPQUFPLElBQVEsTUFBTTtJQUN6QixJQUFJQyxRQUFRLElBQU8sTUFBTTtJQUV6QixJQUFJQyxlQUFlO0lBQ25CLElBQUlDLGVBQWU7SUFFbkIscUNBQXFDO0lBQ3JDLElBQUlULFFBQVFELFlBQVlBLFlBQVlFLE1BQU07UUFDeEMsT0FBUUYsV0FBV0M7SUFDckI7SUFFQSxzQ0FBc0M7SUFDdEMsSUFBSUUsV0FBV0gsWUFBWUEsWUFBWUksU0FBUztRQUM5QyxPQUFRSixXQUFXRyxVQUFVTTtJQUMvQjtJQUVBLHNCQUFzQjtJQUN0QixJQUFJSixRQUFRTCxZQUFZQSxZQUFZTSxNQUFNO1FBQ3hDLE9BQVFOLFdBQVdLLE9BQU9LO0lBQzVCO0lBRUEsUUFBUTtJQUNSLElBQUlWLFlBQVlPLE1BQU07UUFDcEIsT0FBTztJQUNUO0lBRUEsUUFBUTtJQUNSLElBQUlQLFlBQVlRLE9BQU87UUFDckIsT0FBTztJQUNUO0lBRUEsd0JBQXdCO0lBQ3hCLE9BQU8sQ0FBQztBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd29ya2Zsb3cvLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1qcy9saWIvYmFzZTY0LmpzP2EyMjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgaW50VG9DaGFyTWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLnNwbGl0KCcnKTtcblxuLyoqXG4gKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgaWYgKDAgPD0gbnVtYmVyICYmIG51bWJlciA8IGludFRvQ2hhck1hcC5sZW5ndGgpIHtcbiAgICByZXR1cm4gaW50VG9DaGFyTWFwW251bWJlcl07XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBudW1iZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBjaGFyYWN0ZXIgY29kZSBkaWdpdCB0byBhbiBpbnRlZ2VyLiBSZXR1cm5zIC0xIG9uXG4gKiBmYWlsdXJlLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICB2YXIgYmlnQSA9IDY1OyAgICAgLy8gJ0EnXG4gIHZhciBiaWdaID0gOTA7ICAgICAvLyAnWidcblxuICB2YXIgbGl0dGxlQSA9IDk3OyAgLy8gJ2EnXG4gIHZhciBsaXR0bGVaID0gMTIyOyAvLyAneidcblxuICB2YXIgemVybyA9IDQ4OyAgICAgLy8gJzAnXG4gIHZhciBuaW5lID0gNTc7ICAgICAvLyAnOSdcblxuICB2YXIgcGx1cyA9IDQzOyAgICAgLy8gJysnXG4gIHZhciBzbGFzaCA9IDQ3OyAgICAvLyAnLydcblxuICB2YXIgbGl0dGxlT2Zmc2V0ID0gMjY7XG4gIHZhciBudW1iZXJPZmZzZXQgPSA1MjtcblxuICAvLyAwIC0gMjU6IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXG4gIGlmIChiaWdBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGJpZ1opIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gYmlnQSk7XG4gIH1cblxuICAvLyAyNiAtIDUxOiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxuICBpZiAobGl0dGxlQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBsaXR0bGVaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGxpdHRsZUEgKyBsaXR0bGVPZmZzZXQpO1xuICB9XG5cbiAgLy8gNTIgLSA2MTogMDEyMzQ1Njc4OVxuICBpZiAoemVybyA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBuaW5lKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIHplcm8gKyBudW1iZXJPZmZzZXQpO1xuICB9XG5cbiAgLy8gNjI6ICtcbiAgaWYgKGNoYXJDb2RlID09IHBsdXMpIHtcbiAgICByZXR1cm4gNjI7XG4gIH1cblxuICAvLyA2MzogL1xuICBpZiAoY2hhckNvZGUgPT0gc2xhc2gpIHtcbiAgICByZXR1cm4gNjM7XG4gIH1cblxuICAvLyBJbnZhbGlkIGJhc2U2NCBkaWdpdC5cbiAgcmV0dXJuIC0xO1xufTtcbiJdLCJuYW1lcyI6WyJpbnRUb0NoYXJNYXAiLCJzcGxpdCIsImV4cG9ydHMiLCJlbmNvZGUiLCJudW1iZXIiLCJsZW5ndGgiLCJUeXBlRXJyb3IiLCJkZWNvZGUiLCJjaGFyQ29kZSIsImJpZ0EiLCJiaWdaIiwibGl0dGxlQSIsImxpdHRsZVoiLCJ6ZXJvIiwibmluZSIsInBsdXMiLCJzbGFzaCIsImxpdHRsZU9mZnNldCIsIm51bWJlck9mZnNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/source-map-js/lib/base64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/source-map-js/lib/binary-search.js":
/*!*********************************************************!*\
  !*** ./node_modules/source-map-js/lib/binary-search.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ exports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */ function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n    // This function terminates when one of the following is true:\n    //\n    //   1. We find the exact element we are looking for.\n    //\n    //   2. We did not find the exact element, but we can return the index of\n    //      the next-closest element.\n    //\n    //   3. We did not find the exact element, and there is no next-closest\n    //      element than the one we are searching for, so we return -1.\n    var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n    var cmp = aCompare(aNeedle, aHaystack[mid], true);\n    if (cmp === 0) {\n        // Found the element we are looking for.\n        return mid;\n    } else if (cmp > 0) {\n        // Our needle is greater than aHaystack[mid].\n        if (aHigh - mid > 1) {\n            // The element is in the upper half.\n            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n        }\n        // The exact needle element was not found in this haystack. Determine if\n        // we are in termination case (3) or (2) and return the appropriate thing.\n        if (aBias == exports.LEAST_UPPER_BOUND) {\n            return aHigh < aHaystack.length ? aHigh : -1;\n        } else {\n            return mid;\n        }\n    } else {\n        // Our needle is less than aHaystack[mid].\n        if (mid - aLow > 1) {\n            // The element is in the lower half.\n            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n        }\n        // we are in termination case (3) or (2) and return the appropriate thing.\n        if (aBias == exports.LEAST_UPPER_BOUND) {\n            return mid;\n        } else {\n            return aLow < 0 ? -1 : aLow;\n        }\n    }\n}\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */ exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n    if (aHaystack.length === 0) {\n        return -1;\n    }\n    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n    if (index < 0) {\n        return -1;\n    }\n    // We have found either the exact element, or the next-closest element than\n    // the one we are searching for. However, there may be more than one such\n    // element. Make sure we always return the smallest of these.\n    while(index - 1 >= 0){\n        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n            break;\n        }\n        --index;\n    }\n    return index;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1qcy9saWIvYmluYXJ5LXNlYXJjaC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5Q0FBeUMsR0FDekM7Ozs7Q0FJQyxHQUVEQSw0QkFBNEIsR0FBRztBQUMvQkEseUJBQXlCLEdBQUc7QUFFNUI7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsU0FBU0csZ0JBQWdCQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsT0FBTyxFQUFFQyxTQUFTLEVBQUVDLFFBQVEsRUFBRUMsS0FBSztJQUN2RSw4REFBOEQ7SUFDOUQsRUFBRTtJQUNGLHFEQUFxRDtJQUNyRCxFQUFFO0lBQ0YseUVBQXlFO0lBQ3pFLGlDQUFpQztJQUNqQyxFQUFFO0lBQ0YsdUVBQXVFO0lBQ3ZFLG1FQUFtRTtJQUNuRSxJQUFJQyxNQUFNQyxLQUFLQyxLQUFLLENBQUMsQ0FBQ1AsUUFBUUQsSUFBRyxJQUFLLEtBQUtBO0lBQzNDLElBQUlTLE1BQU1MLFNBQVNGLFNBQVNDLFNBQVMsQ0FBQ0csSUFBSSxFQUFFO0lBQzVDLElBQUlHLFFBQVEsR0FBRztRQUNiLHdDQUF3QztRQUN4QyxPQUFPSDtJQUNULE9BQ0ssSUFBSUcsTUFBTSxHQUFHO1FBQ2hCLDZDQUE2QztRQUM3QyxJQUFJUixRQUFRSyxNQUFNLEdBQUc7WUFDbkIsb0NBQW9DO1lBQ3BDLE9BQU9QLGdCQUFnQk8sS0FBS0wsT0FBT0MsU0FBU0MsV0FBV0MsVUFBVUM7UUFDbkU7UUFFQSx3RUFBd0U7UUFDeEUsMEVBQTBFO1FBQzFFLElBQUlBLFNBQVNULFFBQVFFLGlCQUFpQixFQUFFO1lBQ3RDLE9BQU9HLFFBQVFFLFVBQVVPLE1BQU0sR0FBR1QsUUFBUSxDQUFDO1FBQzdDLE9BQU87WUFDTCxPQUFPSztRQUNUO0lBQ0YsT0FDSztRQUNILDBDQUEwQztRQUMxQyxJQUFJQSxNQUFNTixPQUFPLEdBQUc7WUFDbEIsb0NBQW9DO1lBQ3BDLE9BQU9ELGdCQUFnQkMsTUFBTU0sS0FBS0osU0FBU0MsV0FBV0MsVUFBVUM7UUFDbEU7UUFFQSwwRUFBMEU7UUFDMUUsSUFBSUEsU0FBU1QsUUFBUUUsaUJBQWlCLEVBQUU7WUFDdEMsT0FBT1E7UUFDVCxPQUFPO1lBQ0wsT0FBT04sT0FBTyxJQUFJLENBQUMsSUFBSUE7UUFDekI7SUFDRjtBQUNGO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ0RKLGNBQWMsR0FBRyxTQUFTZSxPQUFPVCxPQUFPLEVBQUVDLFNBQVMsRUFBRUMsUUFBUSxFQUFFQyxLQUFLO0lBQ2xFLElBQUlGLFVBQVVPLE1BQU0sS0FBSyxHQUFHO1FBQzFCLE9BQU8sQ0FBQztJQUNWO0lBRUEsSUFBSUUsUUFBUWIsZ0JBQWdCLENBQUMsR0FBR0ksVUFBVU8sTUFBTSxFQUFFUixTQUFTQyxXQUMvQkMsVUFBVUMsU0FBU1QsUUFBUUMsb0JBQW9CO0lBQzNFLElBQUllLFFBQVEsR0FBRztRQUNiLE9BQU8sQ0FBQztJQUNWO0lBRUEsMkVBQTJFO0lBQzNFLHlFQUF5RTtJQUN6RSw2REFBNkQ7SUFDN0QsTUFBT0EsUUFBUSxLQUFLLEVBQUc7UUFDckIsSUFBSVIsU0FBU0QsU0FBUyxDQUFDUyxNQUFNLEVBQUVULFNBQVMsQ0FBQ1MsUUFBUSxFQUFFLEVBQUUsVUFBVSxHQUFHO1lBQ2hFO1FBQ0Y7UUFDQSxFQUFFQTtJQUNKO0lBRUEsT0FBT0E7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL3dvcmtmbG93Ly4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtanMvbGliL2JpbmFyeS1zZWFyY2guanM/ODdjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbmV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gKlxuICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICovXG5mdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gIC8vXG4gIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gIC8vXG4gIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2ZcbiAgLy8gICAgICB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4gIC8vXG4gIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gIC8vICAgICAgZWxlbWVudCB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlIHJldHVybiAtMS5cbiAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gIGlmIChjbXAgPT09IDApIHtcbiAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgcmV0dXJuIG1pZDtcbiAgfVxuICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBncmVhdGVyIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZXhhY3QgbmVlZGxlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZCBpbiB0aGlzIGhheXN0YWNrLiBEZXRlcm1pbmUgaWZcbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gYUhpZ2ggPCBhSGF5c3RhY2subGVuZ3RoID8gYUhpZ2ggOiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBsZXNzIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2goYUxvdywgbWlkLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFMb3cgPCAwID8gLTEgOiBhTG93O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICogdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzIGJlY2F1c2VcbiAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gKiB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gKlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqL1xuZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICB2YXIgaW5kZXggPSByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb21wYXJlLCBhQmlhcyB8fCBleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIFdlIGhhdmUgZm91bmQgZWl0aGVyIHRoZSBleGFjdCBlbGVtZW50LCBvciB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQgdGhhblxuICAvLyB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoXG4gIC8vIGVsZW1lbnQuIE1ha2Ugc3VyZSB3ZSBhbHdheXMgcmV0dXJuIHRoZSBzbWFsbGVzdCBvZiB0aGVzZS5cbiAgd2hpbGUgKGluZGV4IC0gMSA+PSAwKSB7XG4gICAgaWYgKGFDb21wYXJlKGFIYXlzdGFja1tpbmRleF0sIGFIYXlzdGFja1tpbmRleCAtIDFdLCB0cnVlKSAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC0taW5kZXg7XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59O1xuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJHUkVBVEVTVF9MT1dFUl9CT1VORCIsIkxFQVNUX1VQUEVSX0JPVU5EIiwicmVjdXJzaXZlU2VhcmNoIiwiYUxvdyIsImFIaWdoIiwiYU5lZWRsZSIsImFIYXlzdGFjayIsImFDb21wYXJlIiwiYUJpYXMiLCJtaWQiLCJNYXRoIiwiZmxvb3IiLCJjbXAiLCJsZW5ndGgiLCJzZWFyY2giLCJpbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/source-map-js/lib/binary-search.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/source-map-js/lib/mapping-list.js":
/*!********************************************************!*\
  !*** ./node_modules/source-map-js/lib/mapping-list.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/source-map-js/lib/util.js\");\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */ function generatedPositionAfter(mappingA, mappingB) {\n    // Optimized for most common case\n    var lineA = mappingA.generatedLine;\n    var lineB = mappingB.generatedLine;\n    var columnA = mappingA.generatedColumn;\n    var columnB = mappingB.generatedColumn;\n    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */ function MappingList() {\n    this._array = [];\n    this._sorted = true;\n    // Serves as infimum\n    this._last = {\n        generatedLine: -1,\n        generatedColumn: 0\n    };\n}\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */ MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n};\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */ MappingList.prototype.add = function MappingList_add(aMapping) {\n    if (generatedPositionAfter(this._last, aMapping)) {\n        this._last = aMapping;\n        this._array.push(aMapping);\n    } else {\n        this._sorted = false;\n        this._array.push(aMapping);\n    }\n};\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */ MappingList.prototype.toArray = function MappingList_toArray() {\n    if (!this._sorted) {\n        this._array.sort(util.compareByGeneratedPositionsInflated);\n        this._sorted = true;\n    }\n    return this._array;\n};\nexports.MappingList = MappingList;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1qcy9saWIvbWFwcGluZy1saXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBLHlDQUF5QyxHQUN6Qzs7OztDQUlDLEdBRUQsSUFBSUEsT0FBT0MsbUJBQU9BLENBQUM7QUFFbkI7OztDQUdDLEdBQ0QsU0FBU0MsdUJBQXVCQyxRQUFRLEVBQUVDLFFBQVE7SUFDaEQsaUNBQWlDO0lBQ2pDLElBQUlDLFFBQVFGLFNBQVNHLGFBQWE7SUFDbEMsSUFBSUMsUUFBUUgsU0FBU0UsYUFBYTtJQUNsQyxJQUFJRSxVQUFVTCxTQUFTTSxlQUFlO0lBQ3RDLElBQUlDLFVBQVVOLFNBQVNLLGVBQWU7SUFDdEMsT0FBT0YsUUFBUUYsU0FBU0UsU0FBU0YsU0FBU0ssV0FBV0YsV0FDOUNSLEtBQUtXLG1DQUFtQyxDQUFDUixVQUFVQyxhQUFhO0FBQ3pFO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNRO0lBQ1AsSUFBSSxDQUFDQyxNQUFNLEdBQUcsRUFBRTtJQUNoQixJQUFJLENBQUNDLE9BQU8sR0FBRztJQUNmLG9CQUFvQjtJQUNwQixJQUFJLENBQUNDLEtBQUssR0FBRztRQUFDVCxlQUFlLENBQUM7UUFBR0csaUJBQWlCO0lBQUM7QUFDckQ7QUFFQTs7Ozs7Q0FLQyxHQUNERyxZQUFZSSxTQUFTLENBQUNDLGVBQWUsR0FDbkMsU0FBU0Msb0JBQW9CQyxTQUFTLEVBQUVDLFFBQVE7SUFDOUMsSUFBSSxDQUFDUCxNQUFNLENBQUNRLE9BQU8sQ0FBQ0YsV0FBV0M7QUFDakM7QUFFRjs7OztDQUlDLEdBQ0RSLFlBQVlJLFNBQVMsQ0FBQ00sR0FBRyxHQUFHLFNBQVNDLGdCQUFnQkMsUUFBUTtJQUMzRCxJQUFJdEIsdUJBQXVCLElBQUksQ0FBQ2EsS0FBSyxFQUFFUyxXQUFXO1FBQ2hELElBQUksQ0FBQ1QsS0FBSyxHQUFHUztRQUNiLElBQUksQ0FBQ1gsTUFBTSxDQUFDWSxJQUFJLENBQUNEO0lBQ25CLE9BQU87UUFDTCxJQUFJLENBQUNWLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0QsTUFBTSxDQUFDWSxJQUFJLENBQUNEO0lBQ25CO0FBQ0Y7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNEWixZQUFZSSxTQUFTLENBQUNVLE9BQU8sR0FBRyxTQUFTQztJQUN2QyxJQUFJLENBQUMsSUFBSSxDQUFDYixPQUFPLEVBQUU7UUFDakIsSUFBSSxDQUFDRCxNQUFNLENBQUNlLElBQUksQ0FBQzVCLEtBQUtXLG1DQUFtQztRQUN6RCxJQUFJLENBQUNHLE9BQU8sR0FBRztJQUNqQjtJQUNBLE9BQU8sSUFBSSxDQUFDRCxNQUFNO0FBQ3BCO0FBRUFnQixtQkFBbUIsR0FBR2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd29ya2Zsb3cvLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1qcy9saWIvbWFwcGluZy1saXN0LmpzP2E0NGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDE0IE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIG1hcHBpbmdCIGlzIGFmdGVyIG1hcHBpbmdBIHdpdGggcmVzcGVjdCB0byBnZW5lcmF0ZWRcbiAqIHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICAvLyBPcHRpbWl6ZWQgZm9yIG1vc3QgY29tbW9uIGNhc2VcbiAgdmFyIGxpbmVBID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZTtcbiAgdmFyIGxpbmVCID0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgdmFyIGNvbHVtbkEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW47XG4gIHZhciBjb2x1bW5CID0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICByZXR1cm4gbGluZUIgPiBsaW5lQSB8fCBsaW5lQiA9PSBsaW5lQSAmJiBjb2x1bW5CID49IGNvbHVtbkEgfHxcbiAgICAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSA8PSAwO1xufVxuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgdG8gcHJvdmlkZSBhIHNvcnRlZCB2aWV3IG9mIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIGFcbiAqIHBlcmZvcm1hbmNlIGNvbnNjaW91cyBtYW5uZXIuIEl0IHRyYWRlcyBhIG5lZ2xpYmFibGUgb3ZlcmhlYWQgaW4gZ2VuZXJhbFxuICogY2FzZSBmb3IgYSBsYXJnZSBzcGVlZHVwIGluIGNhc2Ugb2YgbWFwcGluZ3MgYmVpbmcgYWRkZWQgaW4gb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmdMaXN0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICAvLyBTZXJ2ZXMgYXMgaW5maW11bVxuICB0aGlzLl9sYXN0ID0ge2dlbmVyYXRlZExpbmU6IC0xLCBnZW5lcmF0ZWRDb2x1bW46IDB9O1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgdGhyb3VnaCBpbnRlcm5hbCBpdGVtcy4gVGhpcyBtZXRob2QgdGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIHRoYXRcbiAqIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgdGFrZXMuXG4gKlxuICogTk9URTogVGhlIG9yZGVyIG9mIHRoZSBtYXBwaW5ncyBpcyBOT1QgZ3VhcmFudGVlZC5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnVuc29ydGVkRm9yRWFjaCA9XG4gIGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2ZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZykge1xuICAgIHRoaXMuX2FycmF5LmZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZyk7XG4gIH07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBzb3VyY2UgbWFwcGluZy5cbiAqXG4gKiBAcGFyYW0gT2JqZWN0IGFNYXBwaW5nXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF9hZGQoYU1hcHBpbmcpIHtcbiAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIodGhpcy5fbGFzdCwgYU1hcHBpbmcpKSB7XG4gICAgdGhpcy5fbGFzdCA9IGFNYXBwaW5nO1xuICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZsYXQsIHNvcnRlZCBhcnJheSBvZiBtYXBwaW5ncy4gVGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQgYnlcbiAqIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAqXG4gKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCByZXR1cm5zIGludGVybmFsIGRhdGEgd2l0aG91dCBjb3B5aW5nLCBmb3JcbiAqIHBlcmZvcm1hbmNlLiBUaGUgcmV0dXJuIHZhbHVlIG11c3QgTk9UIGJlIG11dGF0ZWQsIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhc1xuICogYW4gaW1tdXRhYmxlIGJvcnJvdy4gSWYgeW91IHdhbnQgdG8gdGFrZSBvd25lcnNoaXAsIHlvdSBtdXN0IG1ha2UgeW91ciBvd25cbiAqIGNvcHkuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfdG9BcnJheSgpIHtcbiAgaWYgKCF0aGlzLl9zb3J0ZWQpIHtcbiAgICB0aGlzLl9hcnJheS5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQpO1xuICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5O1xufTtcblxuZXhwb3J0cy5NYXBwaW5nTGlzdCA9IE1hcHBpbmdMaXN0O1xuIl0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwiZ2VuZXJhdGVkUG9zaXRpb25BZnRlciIsIm1hcHBpbmdBIiwibWFwcGluZ0IiLCJsaW5lQSIsImdlbmVyYXRlZExpbmUiLCJsaW5lQiIsImNvbHVtbkEiLCJnZW5lcmF0ZWRDb2x1bW4iLCJjb2x1bW5CIiwiY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQiLCJNYXBwaW5nTGlzdCIsIl9hcnJheSIsIl9zb3J0ZWQiLCJfbGFzdCIsInByb3RvdHlwZSIsInVuc29ydGVkRm9yRWFjaCIsIk1hcHBpbmdMaXN0X2ZvckVhY2giLCJhQ2FsbGJhY2siLCJhVGhpc0FyZyIsImZvckVhY2giLCJhZGQiLCJNYXBwaW5nTGlzdF9hZGQiLCJhTWFwcGluZyIsInB1c2giLCJ0b0FycmF5IiwiTWFwcGluZ0xpc3RfdG9BcnJheSIsInNvcnQiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/source-map-js/lib/mapping-list.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/source-map-js/lib/quick-sort.js":
/*!******************************************************!*\
  !*** ./node_modules/source-map-js/lib/quick-sort.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ // It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\nfunction SortTemplate(comparator) {\n    /**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */ function swap(ary, x, y) {\n        var temp = ary[x];\n        ary[x] = ary[y];\n        ary[y] = temp;\n    }\n    /**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */ function randomIntInRange(low, high) {\n        return Math.round(low + Math.random() * (high - low));\n    }\n    /**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */ function doQuickSort(ary, comparator, p, r) {\n        // If our lower bound is less than our upper bound, we (1) partition the\n        // array into two pieces and (2) recurse on each half. If it is not, this is\n        // the empty array and our base case.\n        if (p < r) {\n            // (1) Partitioning.\n            //\n            // The partitioning chooses a pivot between `p` and `r` and moves all\n            // elements that are less than or equal to the pivot to the before it, and\n            // all the elements that are greater than it after it. The effect is that\n            // once partition is done, the pivot is in the exact place it will be when\n            // the array is put in sorted order, and it will not need to be moved\n            // again. This runs in O(n) time.\n            // Always choose a random pivot so that an input array which is reverse\n            // sorted does not cause O(n^2) running time.\n            var pivotIndex = randomIntInRange(p, r);\n            var i = p - 1;\n            swap(ary, pivotIndex, r);\n            var pivot = ary[r];\n            // Immediately after `j` is incremented in this loop, the following hold\n            // true:\n            //\n            //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n            //\n            //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n            for(var j = p; j < r; j++){\n                if (comparator(ary[j], pivot, false) <= 0) {\n                    i += 1;\n                    swap(ary, i, j);\n                }\n            }\n            swap(ary, i + 1, j);\n            var q = i + 1;\n            // (2) Recurse on each half.\n            doQuickSort(ary, comparator, p, q - 1);\n            doQuickSort(ary, comparator, q + 1, r);\n        }\n    }\n    return doQuickSort;\n}\nfunction cloneSort(comparator) {\n    let template = SortTemplate.toString();\n    let templateFn = new Function(`return ${template}`)();\n    return templateFn(comparator);\n}\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */ let sortCache = new WeakMap();\nexports.quickSort = function(ary, comparator, start = 0) {\n    let doQuickSort = sortCache.get(comparator);\n    if (doQuickSort === void 0) {\n        doQuickSort = cloneSort(comparator);\n        sortCache.set(comparator, doQuickSort);\n    }\n    doQuickSort(ary, comparator, start, ary.length - 1);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1qcy9saWIvcXVpY2stc29ydC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5Q0FBeUMsR0FDekM7Ozs7Q0FJQyxHQUVELG9FQUFvRTtBQUNwRSwwRUFBMEU7QUFDMUUsNkVBQTZFO0FBQzdFLDhFQUE4RTtBQUM5RSx5RUFBeUU7QUFDekUsNkVBQTZFO0FBQzdFLDZFQUE2RTtBQUM3RSw2RUFBNkU7QUFDN0UsaURBQWlEO0FBRWpELFNBQVNBLGFBQWFDLFVBQVU7SUFFaEM7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU0MsS0FBS0MsR0FBRyxFQUFFQyxDQUFDLEVBQUVDLENBQUM7UUFDckIsSUFBSUMsT0FBT0gsR0FBRyxDQUFDQyxFQUFFO1FBQ2pCRCxHQUFHLENBQUNDLEVBQUUsR0FBR0QsR0FBRyxDQUFDRSxFQUFFO1FBQ2ZGLEdBQUcsQ0FBQ0UsRUFBRSxHQUFHQztJQUNYO0lBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNDLGlCQUFpQkMsR0FBRyxFQUFFQyxJQUFJO1FBQ2pDLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0gsTUFBT0UsS0FBS0UsTUFBTSxLQUFNSCxDQUFBQSxPQUFPRCxHQUFFO0lBQ3JEO0lBRUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxTQUFTSyxZQUFZVixHQUFHLEVBQUVGLFVBQVUsRUFBRWEsQ0FBQyxFQUFFQyxDQUFDO1FBQ3hDLHdFQUF3RTtRQUN4RSw0RUFBNEU7UUFDNUUscUNBQXFDO1FBRXJDLElBQUlELElBQUlDLEdBQUc7WUFDVCxvQkFBb0I7WUFDcEIsRUFBRTtZQUNGLHFFQUFxRTtZQUNyRSwwRUFBMEU7WUFDMUUseUVBQXlFO1lBQ3pFLDBFQUEwRTtZQUMxRSxxRUFBcUU7WUFDckUsaUNBQWlDO1lBRWpDLHVFQUF1RTtZQUN2RSw2Q0FBNkM7WUFDN0MsSUFBSUMsYUFBYVQsaUJBQWlCTyxHQUFHQztZQUNyQyxJQUFJRSxJQUFJSCxJQUFJO1lBRVpaLEtBQUtDLEtBQUthLFlBQVlEO1lBQ3RCLElBQUlHLFFBQVFmLEdBQUcsQ0FBQ1ksRUFBRTtZQUVsQix3RUFBd0U7WUFDeEUsUUFBUTtZQUNSLEVBQUU7WUFDRix5RUFBeUU7WUFDekUsRUFBRTtZQUNGLG9FQUFvRTtZQUNwRSxJQUFLLElBQUlJLElBQUlMLEdBQUdLLElBQUlKLEdBQUdJLElBQUs7Z0JBQzFCLElBQUlsQixXQUFXRSxHQUFHLENBQUNnQixFQUFFLEVBQUVELE9BQU8sVUFBVSxHQUFHO29CQUN6Q0QsS0FBSztvQkFDTGYsS0FBS0MsS0FBS2MsR0FBR0U7Z0JBQ2Y7WUFDRjtZQUVBakIsS0FBS0MsS0FBS2MsSUFBSSxHQUFHRTtZQUNqQixJQUFJQyxJQUFJSCxJQUFJO1lBRVosNEJBQTRCO1lBRTVCSixZQUFZVixLQUFLRixZQUFZYSxHQUFHTSxJQUFJO1lBQ3BDUCxZQUFZVixLQUFLRixZQUFZbUIsSUFBSSxHQUFHTDtRQUN0QztJQUNGO0lBRUUsT0FBT0Y7QUFDVDtBQUVBLFNBQVNRLFVBQVVwQixVQUFVO0lBQzNCLElBQUlxQixXQUFXdEIsYUFBYXVCLFFBQVE7SUFDcEMsSUFBSUMsYUFBYSxJQUFJQyxTQUFTLENBQUMsT0FBTyxFQUFFSCxTQUFTLENBQUM7SUFDbEQsT0FBT0UsV0FBV3ZCO0FBQ3BCO0FBRUE7Ozs7Ozs7Q0FPQyxHQUVELElBQUl5QixZQUFZLElBQUlDO0FBQ3BCQyxpQkFBaUIsR0FBRyxTQUFVekIsR0FBRyxFQUFFRixVQUFVLEVBQUU2QixRQUFRLENBQUM7SUFDdEQsSUFBSWpCLGNBQWNhLFVBQVVLLEdBQUcsQ0FBQzlCO0lBQ2hDLElBQUlZLGdCQUFnQixLQUFLLEdBQUc7UUFDMUJBLGNBQWNRLFVBQVVwQjtRQUN4QnlCLFVBQVVNLEdBQUcsQ0FBQy9CLFlBQVlZO0lBQzVCO0lBQ0FBLFlBQVlWLEtBQUtGLFlBQVk2QixPQUFPM0IsSUFBSThCLE1BQU0sR0FBRztBQUNuRCIsInNvdXJjZXMiOlsid2VicGFjazovL3dvcmtmbG93Ly4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtanMvbGliL3F1aWNrLXNvcnQuanM/ZmE4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8vIEl0IHR1cm5zIG91dCB0aGF0IHNvbWUgKG1vc3Q/KSBKYXZhU2NyaXB0IGVuZ2luZXMgZG9uJ3Qgc2VsZi1ob3N0XG4vLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgLiBUaGlzIG1ha2VzIHNlbnNlIGJlY2F1c2UgQysrIHdpbGwgbGlrZWx5IHJlbWFpblxuLy8gZmFzdGVyIHRoYW4gSlMgd2hlbiBkb2luZyByYXcgQ1BVLWludGVuc2l2ZSBzb3J0aW5nLiBIb3dldmVyLCB3aGVuIHVzaW5nIGFcbi8vIGN1c3RvbSBjb21wYXJhdG9yIGZ1bmN0aW9uLCBjYWxsaW5nIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gdGhlIFZNJ3MgQysrIGFuZFxuLy8gSklUJ2QgSlMgaXMgcmF0aGVyIHNsb3cgKmFuZCogbG9zZXMgSklUIHR5cGUgaW5mb3JtYXRpb24sIHJlc3VsdGluZyBpblxuLy8gd29yc2UgZ2VuZXJhdGVkIGNvZGUgZm9yIHRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRoYW4gd291bGQgYmUgb3B0aW1hbC4gSW5cbi8vIGZhY3QsIHdoZW4gc29ydGluZyB3aXRoIGEgY29tcGFyYXRvciwgdGhlc2UgY29zdHMgb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIG9mXG4vLyBzb3J0aW5nIGluIEMrKy4gQnkgdXNpbmcgb3VyIG93biBKUy1pbXBsZW1lbnRlZCBRdWljayBTb3J0IChiZWxvdyksIHdlIGdldFxuLy8gYSB+MzUwMG1zIG1lYW4gc3BlZWQtdXAgaW4gYGJlbmNoL2JlbmNoLmh0bWxgLlxuXG5mdW5jdGlvbiBTb3J0VGVtcGxhdGUoY29tcGFyYXRvcikge1xuXG4vKipcbiAqIFN3YXAgdGhlIGVsZW1lbnRzIGluZGV4ZWQgYnkgYHhgIGFuZCBgeWAgaW4gdGhlIGFycmF5IGBhcnlgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIFRoZSBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtLlxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHNlY29uZCBpdGVtLlxuICovXG5mdW5jdGlvbiBzd2FwKGFyeSwgeCwgeSkge1xuICB2YXIgdGVtcCA9IGFyeVt4XTtcbiAgYXJ5W3hdID0gYXJ5W3ldO1xuICBhcnlbeV0gPSB0ZW1wO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciB3aXRoaW4gdGhlIHJhbmdlIGBsb3cgLi4gaGlnaGAgaW5jbHVzaXZlLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dcbiAqICAgICAgICBUaGUgbG93ZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2hcbiAqICAgICAgICBUaGUgdXBwZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICovXG5mdW5jdGlvbiByYW5kb21JbnRJblJhbmdlKGxvdywgaGlnaCkge1xuICByZXR1cm4gTWF0aC5yb3VuZChsb3cgKyAoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KSkpO1xufVxuXG4vKipcbiAqIFRoZSBRdWljayBTb3J0IGFsZ29yaXRobS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwXG4gKiAgICAgICAgU3RhcnQgaW5kZXggb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gclxuICogICAgICAgIEVuZCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqL1xuZnVuY3Rpb24gZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCByKSB7XG4gIC8vIElmIG91ciBsb3dlciBib3VuZCBpcyBsZXNzIHRoYW4gb3VyIHVwcGVyIGJvdW5kLCB3ZSAoMSkgcGFydGl0aW9uIHRoZVxuICAvLyBhcnJheSBpbnRvIHR3byBwaWVjZXMgYW5kICgyKSByZWN1cnNlIG9uIGVhY2ggaGFsZi4gSWYgaXQgaXMgbm90LCB0aGlzIGlzXG4gIC8vIHRoZSBlbXB0eSBhcnJheSBhbmQgb3VyIGJhc2UgY2FzZS5cblxuICBpZiAocCA8IHIpIHtcbiAgICAvLyAoMSkgUGFydGl0aW9uaW5nLlxuICAgIC8vXG4gICAgLy8gVGhlIHBhcnRpdGlvbmluZyBjaG9vc2VzIGEgcGl2b3QgYmV0d2VlbiBgcGAgYW5kIGByYCBhbmQgbW92ZXMgYWxsXG4gICAgLy8gZWxlbWVudHMgdGhhdCBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdCB0byB0aGUgYmVmb3JlIGl0LCBhbmRcbiAgICAvLyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgYXJlIGdyZWF0ZXIgdGhhbiBpdCBhZnRlciBpdC4gVGhlIGVmZmVjdCBpcyB0aGF0XG4gICAgLy8gb25jZSBwYXJ0aXRpb24gaXMgZG9uZSwgdGhlIHBpdm90IGlzIGluIHRoZSBleGFjdCBwbGFjZSBpdCB3aWxsIGJlIHdoZW5cbiAgICAvLyB0aGUgYXJyYXkgaXMgcHV0IGluIHNvcnRlZCBvcmRlciwgYW5kIGl0IHdpbGwgbm90IG5lZWQgdG8gYmUgbW92ZWRcbiAgICAvLyBhZ2Fpbi4gVGhpcyBydW5zIGluIE8obikgdGltZS5cblxuICAgIC8vIEFsd2F5cyBjaG9vc2UgYSByYW5kb20gcGl2b3Qgc28gdGhhdCBhbiBpbnB1dCBhcnJheSB3aGljaCBpcyByZXZlcnNlXG4gICAgLy8gc29ydGVkIGRvZXMgbm90IGNhdXNlIE8obl4yKSBydW5uaW5nIHRpbWUuXG4gICAgdmFyIHBpdm90SW5kZXggPSByYW5kb21JbnRJblJhbmdlKHAsIHIpO1xuICAgIHZhciBpID0gcCAtIDE7XG5cbiAgICBzd2FwKGFyeSwgcGl2b3RJbmRleCwgcik7XG4gICAgdmFyIHBpdm90ID0gYXJ5W3JdO1xuXG4gICAgLy8gSW1tZWRpYXRlbHkgYWZ0ZXIgYGpgIGlzIGluY3JlbWVudGVkIGluIHRoaXMgbG9vcCwgdGhlIGZvbGxvd2luZyBob2xkXG4gICAgLy8gdHJ1ZTpcbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbcCAuLiBpXWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdC5cbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbaSsxIC4uIGotMV1gIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcGl2b3QuXG4gICAgZm9yICh2YXIgaiA9IHA7IGogPCByOyBqKyspIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFyeVtqXSwgcGl2b3QsIGZhbHNlKSA8PSAwKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgc3dhcChhcnksIGksIGopO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3YXAoYXJ5LCBpICsgMSwgaik7XG4gICAgdmFyIHEgPSBpICsgMTtcblxuICAgIC8vICgyKSBSZWN1cnNlIG9uIGVhY2ggaGFsZi5cblxuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcSAtIDEpO1xuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcSArIDEsIHIpO1xuICB9XG59XG5cbiAgcmV0dXJuIGRvUXVpY2tTb3J0O1xufVxuXG5mdW5jdGlvbiBjbG9uZVNvcnQoY29tcGFyYXRvcikge1xuICBsZXQgdGVtcGxhdGUgPSBTb3J0VGVtcGxhdGUudG9TdHJpbmcoKTtcbiAgbGV0IHRlbXBsYXRlRm4gPSBuZXcgRnVuY3Rpb24oYHJldHVybiAke3RlbXBsYXRlfWApKCk7XG4gIHJldHVybiB0ZW1wbGF0ZUZuKGNvbXBhcmF0b3IpO1xufVxuXG4vKipcbiAqIFNvcnQgdGhlIGdpdmVuIGFycmF5IGluLXBsYWNlIHdpdGggdGhlIGdpdmVuIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKi9cblxubGV0IHNvcnRDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5leHBvcnRzLnF1aWNrU29ydCA9IGZ1bmN0aW9uIChhcnksIGNvbXBhcmF0b3IsIHN0YXJ0ID0gMCkge1xuICBsZXQgZG9RdWlja1NvcnQgPSBzb3J0Q2FjaGUuZ2V0KGNvbXBhcmF0b3IpO1xuICBpZiAoZG9RdWlja1NvcnQgPT09IHZvaWQgMCkge1xuICAgIGRvUXVpY2tTb3J0ID0gY2xvbmVTb3J0KGNvbXBhcmF0b3IpO1xuICAgIHNvcnRDYWNoZS5zZXQoY29tcGFyYXRvciwgZG9RdWlja1NvcnQpO1xuICB9XG4gIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgc3RhcnQsIGFyeS5sZW5ndGggLSAxKTtcbn07XG4iXSwibmFtZXMiOlsiU29ydFRlbXBsYXRlIiwiY29tcGFyYXRvciIsInN3YXAiLCJhcnkiLCJ4IiwieSIsInRlbXAiLCJyYW5kb21JbnRJblJhbmdlIiwibG93IiwiaGlnaCIsIk1hdGgiLCJyb3VuZCIsInJhbmRvbSIsImRvUXVpY2tTb3J0IiwicCIsInIiLCJwaXZvdEluZGV4IiwiaSIsInBpdm90IiwiaiIsInEiLCJjbG9uZVNvcnQiLCJ0ZW1wbGF0ZSIsInRvU3RyaW5nIiwidGVtcGxhdGVGbiIsIkZ1bmN0aW9uIiwic29ydENhY2hlIiwiV2Vha01hcCIsImV4cG9ydHMiLCJxdWlja1NvcnQiLCJzdGFydCIsImdldCIsInNldCIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/source-map-js/lib/quick-sort.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/source-map-js/lib/source-map-consumer.js":
/*!***************************************************************!*\
  !*** ./node_modules/source-map-js/lib/source-map-consumer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/source-map-js/lib/util.js\");\nvar binarySearch = __webpack_require__(/*! ./binary-search */ \"(ssr)/./node_modules/source-map-js/lib/binary-search.js\");\nvar ArraySet = (__webpack_require__(/*! ./array-set */ \"(ssr)/./node_modules/source-map-js/lib/array-set.js\").ArraySet);\nvar base64VLQ = __webpack_require__(/*! ./base64-vlq */ \"(ssr)/./node_modules/source-map-js/lib/base64-vlq.js\");\nvar quickSort = (__webpack_require__(/*! ./quick-sort */ \"(ssr)/./node_modules/source-map-js/lib/quick-sort.js\").quickSort);\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n    }\n    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n}\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\n    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n};\n/**\n * The version of the source mapping spec that we are consuming.\n */ SourceMapConsumer.prototype._version = 3;\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, \"_generatedMappings\", {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n        if (!this.__generatedMappings) {\n            this._parseMappings(this._mappings, this.sourceRoot);\n        }\n        return this.__generatedMappings;\n    }\n});\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, \"_originalMappings\", {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n        if (!this.__originalMappings) {\n            this._parseMappings(this._mappings, this.sourceRoot);\n        }\n        return this.__originalMappings;\n    }\n});\nSourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n};\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */ SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n};\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */ SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n    var mappings;\n    switch(order){\n        case SourceMapConsumer.GENERATED_ORDER:\n            mappings = this._generatedMappings;\n            break;\n        case SourceMapConsumer.ORIGINAL_ORDER:\n            mappings = this._originalMappings;\n            break;\n        default:\n            throw new Error(\"Unknown order of iteration.\");\n    }\n    var sourceRoot = this.sourceRoot;\n    var boundCallback = aCallback.bind(context);\n    var names = this._names;\n    var sources = this._sources;\n    var sourceMapURL = this._sourceMapURL;\n    for(var i = 0, n = mappings.length; i < n; i++){\n        var mapping = mappings[i];\n        var source = mapping.source === null ? null : sources.at(mapping.source);\n        source = util.computeSourceURL(sourceRoot, source, sourceMapURL);\n        boundCallback({\n            source: source,\n            generatedLine: mapping.generatedLine,\n            generatedColumn: mapping.generatedColumn,\n            originalLine: mapping.originalLine,\n            originalColumn: mapping.originalColumn,\n            name: mapping.name === null ? null : names.at(mapping.name)\n        });\n    }\n};\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number is 1-based.\n *   - column: Optional. the column number in the original source.\n *    The column number is 0-based.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *    line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *    The column number is 0-based.\n */ SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, \"line\");\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n        source: util.getArg(aArgs, \"source\"),\n        originalLine: line,\n        originalColumn: util.getArg(aArgs, \"column\", 0)\n    };\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n        return [];\n    }\n    var mappings = [];\n    var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n        var mapping = this._originalMappings[index];\n        if (aArgs.column === undefined) {\n            var originalLine = mapping.originalLine;\n            // Iterate until either we run out of mappings, or we run into\n            // a mapping for a different line than the one we found. Since\n            // mappings are sorted, this is guaranteed to find all mappings for\n            // the line we found.\n            while(mapping && mapping.originalLine === originalLine){\n                mappings.push({\n                    line: util.getArg(mapping, \"generatedLine\", null),\n                    column: util.getArg(mapping, \"generatedColumn\", null),\n                    lastColumn: util.getArg(mapping, \"lastGeneratedColumn\", null)\n                });\n                mapping = this._originalMappings[++index];\n            }\n        } else {\n            var originalColumn = mapping.originalColumn;\n            // Iterate until either we run out of mappings, or we run into\n            // a mapping for a different line than the one we were searching for.\n            // Since mappings are sorted, this is guaranteed to find all mappings for\n            // the line we are searching for.\n            while(mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn){\n                mappings.push({\n                    line: util.getArg(mapping, \"generatedLine\", null),\n                    column: util.getArg(mapping, \"generatedColumn\", null),\n                    lastColumn: util.getArg(mapping, \"lastGeneratedColumn\", null)\n                });\n                mapping = this._originalMappings[++index];\n            }\n        }\n    }\n    return mappings;\n};\nexports.SourceMapConsumer = SourceMapConsumer;\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */ function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n    }\n    var version = util.getArg(sourceMap, \"version\");\n    var sources = util.getArg(sourceMap, \"sources\");\n    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n    // requires the array) to play nice here.\n    var names = util.getArg(sourceMap, \"names\", []);\n    var sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n    var sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n    var mappings = util.getArg(sourceMap, \"mappings\");\n    var file = util.getArg(sourceMap, \"file\", null);\n    // Once again, Sass deviates from the spec and supplies the version as a\n    // string rather than a number, so we use loose equality checking here.\n    if (version != this._version) {\n        throw new Error(\"Unsupported version: \" + version);\n    }\n    if (sourceRoot) {\n        sourceRoot = util.normalize(sourceRoot);\n    }\n    sources = sources.map(String)// Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)// Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function(source) {\n        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;\n    });\n    // Pass `true` below to allow duplicate names and sources. While source maps\n    // are intended to be compressed and deduplicated, the TypeScript compiler\n    // sometimes generates source maps with duplicates in them. See Github issue\n    // #72 and bugzil.la/889492.\n    this._names = ArraySet.fromArray(names.map(String), true);\n    this._sources = ArraySet.fromArray(sources, true);\n    this._absoluteSources = this._sources.toArray().map(function(s) {\n        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n    });\n    this.sourceRoot = sourceRoot;\n    this.sourcesContent = sourcesContent;\n    this._mappings = mappings;\n    this._sourceMapURL = aSourceMapURL;\n    this.file = file;\n}\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n/**\n * Utility function to find the index of a source.  Returns -1 if not\n * found.\n */ BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n        relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n    if (this._sources.has(relativeSource)) {\n        return this._sources.indexOf(relativeSource);\n    }\n    // Maybe aSource is an absolute URL as returned by |sources|.  In\n    // this case we can't simply undo the transform.\n    var i;\n    for(i = 0; i < this._absoluteSources.length; ++i){\n        if (this._absoluteSources[i] == aSource) {\n            return i;\n        }\n    }\n    return -1;\n};\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @param String aSourceMapURL\n *        The URL at which the source map can be found (optional)\n * @returns BasicSourceMapConsumer\n */ BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);\n    smc.file = aSourceMap._file;\n    smc._sourceMapURL = aSourceMapURL;\n    smc._absoluteSources = smc._sources.toArray().map(function(s) {\n        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n    });\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n    for(var i = 0, length = generatedMappings.length; i < length; i++){\n        var srcMapping = generatedMappings[i];\n        var destMapping = new Mapping;\n        destMapping.generatedLine = srcMapping.generatedLine;\n        destMapping.generatedColumn = srcMapping.generatedColumn;\n        if (srcMapping.source) {\n            destMapping.source = sources.indexOf(srcMapping.source);\n            destMapping.originalLine = srcMapping.originalLine;\n            destMapping.originalColumn = srcMapping.originalColumn;\n            if (srcMapping.name) {\n                destMapping.name = names.indexOf(srcMapping.name);\n            }\n            destOriginalMappings.push(destMapping);\n        }\n        destGeneratedMappings.push(destMapping);\n    }\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n    return smc;\n};\n/**\n * The version of the source mapping spec that we are consuming.\n */ BasicSourceMapConsumer.prototype._version = 3;\n/**\n * The list of original sources.\n */ Object.defineProperty(BasicSourceMapConsumer.prototype, \"sources\", {\n    get: function() {\n        return this._absoluteSources.slice();\n    }\n});\n/**\n * Provide the JIT with a nice shape / hidden class.\n */ function Mapping() {\n    this.generatedLine = 0;\n    this.generatedColumn = 0;\n    this.source = null;\n    this.originalLine = null;\n    this.originalColumn = null;\n    this.name = null;\n}\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */ const compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;\nfunction sortGenerated(array, start) {\n    let l = array.length;\n    let n = array.length - start;\n    if (n <= 1) {\n        return;\n    } else if (n == 2) {\n        let a = array[start];\n        let b = array[start + 1];\n        if (compareGenerated(a, b) > 0) {\n            array[start] = b;\n            array[start + 1] = a;\n        }\n    } else if (n < 20) {\n        for(let i = start; i < l; i++){\n            for(let j = i; j > start; j--){\n                let a = array[j - 1];\n                let b = array[j];\n                if (compareGenerated(a, b) <= 0) {\n                    break;\n                }\n                array[j - 1] = b;\n                array[j] = a;\n            }\n        }\n    } else {\n        quickSort(array, compareGenerated, start);\n    }\n}\nBasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n    let subarrayStart = 0;\n    while(index < length){\n        if (aStr.charAt(index) === \";\") {\n            generatedLine++;\n            index++;\n            previousGeneratedColumn = 0;\n            sortGenerated(generatedMappings, subarrayStart);\n            subarrayStart = generatedMappings.length;\n        } else if (aStr.charAt(index) === \",\") {\n            index++;\n        } else {\n            mapping = new Mapping();\n            mapping.generatedLine = generatedLine;\n            for(end = index; end < length; end++){\n                if (this._charIsMappingSeparator(aStr, end)) {\n                    break;\n                }\n            }\n            str = aStr.slice(index, end);\n            segment = [];\n            while(index < end){\n                base64VLQ.decode(aStr, index, temp);\n                value = temp.value;\n                index = temp.rest;\n                segment.push(value);\n            }\n            if (segment.length === 2) {\n                throw new Error(\"Found a source, but no line and column\");\n            }\n            if (segment.length === 3) {\n                throw new Error(\"Found a source and line, but no column\");\n            }\n            // Generated column.\n            mapping.generatedColumn = previousGeneratedColumn + segment[0];\n            previousGeneratedColumn = mapping.generatedColumn;\n            if (segment.length > 1) {\n                // Original source.\n                mapping.source = previousSource + segment[1];\n                previousSource += segment[1];\n                // Original line.\n                mapping.originalLine = previousOriginalLine + segment[2];\n                previousOriginalLine = mapping.originalLine;\n                // Lines are stored 0-based\n                mapping.originalLine += 1;\n                // Original column.\n                mapping.originalColumn = previousOriginalColumn + segment[3];\n                previousOriginalColumn = mapping.originalColumn;\n                if (segment.length > 4) {\n                    // Original name.\n                    mapping.name = previousName + segment[4];\n                    previousName += segment[4];\n                }\n            }\n            generatedMappings.push(mapping);\n            if (typeof mapping.originalLine === \"number\") {\n                let currentSource = mapping.source;\n                while(originalMappings.length <= currentSource){\n                    originalMappings.push(null);\n                }\n                if (originalMappings[currentSource] === null) {\n                    originalMappings[currentSource] = [];\n                }\n                originalMappings[currentSource].push(mapping);\n            }\n        }\n    }\n    sortGenerated(generatedMappings, subarrayStart);\n    this.__generatedMappings = generatedMappings;\n    for(var i = 0; i < originalMappings.length; i++){\n        if (originalMappings[i] != null) {\n            quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);\n        }\n    }\n    this.__originalMappings = [].concat(...originalMappings);\n};\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */ BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n    if (aNeedle[aLineName] <= 0) {\n        throw new TypeError(\"Line must be greater than or equal to 1, got \" + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n        throw new TypeError(\"Column must be greater than or equal to 0, got \" + aNeedle[aColumnName]);\n    }\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n};\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */ BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {\n    for(var index = 0; index < this._generatedMappings.length; ++index){\n        var mapping = this._generatedMappings[index];\n        // Mappings do not contain a field for the last generated columnt. We\n        // can come up with an optimistic estimate, however, by assuming that\n        // mappings are contiguous (i.e. given two consecutive mappings, the\n        // first mapping ends where the second one starts).\n        if (index + 1 < this._generatedMappings.length) {\n            var nextMapping = this._generatedMappings[index + 1];\n            if (mapping.generatedLine === nextMapping.generatedLine) {\n                mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n                continue;\n            }\n        }\n        // The last mapping for each line spans the entire line.\n        mapping.lastGeneratedColumn = Infinity;\n    }\n};\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */ BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n        generatedLine: util.getArg(aArgs, \"line\"),\n        generatedColumn: util.getArg(aArgs, \"column\")\n    };\n    var index = this._findMapping(needle, this._generatedMappings, \"generatedLine\", \"generatedColumn\", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND));\n    if (index >= 0) {\n        var mapping = this._generatedMappings[index];\n        if (mapping.generatedLine === needle.generatedLine) {\n            var source = util.getArg(mapping, \"source\", null);\n            if (source !== null) {\n                source = this._sources.at(source);\n                source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n            }\n            var name = util.getArg(mapping, \"name\", null);\n            if (name !== null) {\n                name = this._names.at(name);\n            }\n            return {\n                source: source,\n                line: util.getArg(mapping, \"originalLine\", null),\n                column: util.getArg(mapping, \"originalColumn\", null),\n                name: name\n            };\n        }\n    }\n    return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n    };\n};\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */ BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n        return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {\n        return sc == null;\n    });\n};\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */ BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n        return null;\n    }\n    var index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n        return this.sourcesContent[index];\n    }\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n        relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n    var url;\n    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {\n        // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n        // many users. We can help them out when they expect file:// URIs to\n        // behave like it would if they were running a local HTTP server. See\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n        var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n        if (url.scheme == \"file\" && this._sources.has(fileUriAbsPath)) {\n            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n        }\n        if ((!url.path || url.path == \"/\") && this._sources.has(\"/\" + relativeSource)) {\n            return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n        }\n    }\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n        return null;\n    } else {\n        throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n    }\n};\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */ BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, \"source\");\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n        return {\n            line: null,\n            column: null,\n            lastColumn: null\n        };\n    }\n    var needle = {\n        source: source,\n        originalLine: util.getArg(aArgs, \"line\"),\n        originalColumn: util.getArg(aArgs, \"column\")\n    };\n    var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND));\n    if (index >= 0) {\n        var mapping = this._originalMappings[index];\n        if (mapping.source === needle.source) {\n            return {\n                line: util.getArg(mapping, \"generatedLine\", null),\n                column: util.getArg(mapping, \"generatedColumn\", null),\n                lastColumn: util.getArg(mapping, \"lastGeneratedColumn\", null)\n            };\n        }\n    }\n    return {\n        line: null,\n        column: null,\n        lastColumn: null\n    };\n};\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */ function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n    }\n    var version = util.getArg(sourceMap, \"version\");\n    var sections = util.getArg(sourceMap, \"sections\");\n    if (version != this._version) {\n        throw new Error(\"Unsupported version: \" + version);\n    }\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n    var lastOffset = {\n        line: -1,\n        column: 0\n    };\n    this._sections = sections.map(function(s) {\n        if (s.url) {\n            // The url field will require support for asynchronicity.\n            // See https://github.com/mozilla/source-map/issues/16\n            throw new Error(\"Support for url field in sections not implemented.\");\n        }\n        var offset = util.getArg(s, \"offset\");\n        var offsetLine = util.getArg(offset, \"line\");\n        var offsetColumn = util.getArg(offset, \"column\");\n        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {\n            throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n        }\n        lastOffset = offset;\n        return {\n            generatedOffset: {\n                // The offset fields are 0-based, but we use 1-based indices when\n                // encoding/decoding from VLQ.\n                generatedLine: offsetLine + 1,\n                generatedColumn: offsetColumn + 1\n            },\n            consumer: new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL)\n        };\n    });\n}\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n/**\n * The version of the source mapping spec that we are consuming.\n */ IndexedSourceMapConsumer.prototype._version = 3;\n/**\n * The list of original sources.\n */ Object.defineProperty(IndexedSourceMapConsumer.prototype, \"sources\", {\n    get: function() {\n        var sources = [];\n        for(var i = 0; i < this._sections.length; i++){\n            for(var j = 0; j < this._sections[i].consumer.sources.length; j++){\n                sources.push(this._sections[i].consumer.sources[j]);\n            }\n        }\n        return sources;\n    }\n});\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */ IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n        generatedLine: util.getArg(aArgs, \"line\"),\n        generatedColumn: util.getArg(aArgs, \"column\")\n    };\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections, function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n            return cmp;\n        }\n        return needle.generatedColumn - section.generatedOffset.generatedColumn;\n    });\n    var section = this._sections[sectionIndex];\n    if (!section) {\n        return {\n            source: null,\n            line: null,\n            column: null,\n            name: null\n        };\n    }\n    return section.consumer.originalPositionFor({\n        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\n        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n        bias: aArgs.bias\n    });\n};\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */ IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function(s) {\n        return s.consumer.hasContentsOfAllSources();\n    });\n};\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */ IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for(var i = 0; i < this._sections.length; i++){\n        var section = this._sections[i];\n        var content = section.consumer.sourceContentFor(aSource, true);\n        if (content) {\n            return content;\n        }\n    }\n    if (nullOnMissing) {\n        return null;\n    } else {\n        throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n};\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based. \n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */ IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for(var i = 0; i < this._sections.length; i++){\n        var section = this._sections[i];\n        // Only consider this section if the requested source is in the list of\n        // sources of the consumer.\n        if (section.consumer._findSourceIndex(util.getArg(aArgs, \"source\")) === -1) {\n            continue;\n        }\n        var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n        if (generatedPosition) {\n            var ret = {\n                line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),\n                column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)\n            };\n            return ret;\n        }\n    }\n    return {\n        line: null,\n        column: null\n    };\n};\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */ IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for(var i = 0; i < this._sections.length; i++){\n        var section = this._sections[i];\n        var sectionMappings = section.consumer._generatedMappings;\n        for(var j = 0; j < sectionMappings.length; j++){\n            var mapping = sectionMappings[j];\n            var source = section.consumer._sources.at(mapping.source);\n            source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n            this._sources.add(source);\n            source = this._sources.indexOf(source);\n            var name = null;\n            if (mapping.name) {\n                name = section.consumer._names.at(mapping.name);\n                this._names.add(name);\n                name = this._names.indexOf(name);\n            }\n            // The mappings coming from the consumer for the section have\n            // generated positions relative to the start of the section, so we\n            // need to offset them to be relative to the start of the concatenated\n            // generated file.\n            var adjustedMapping = {\n                source: source,\n                generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),\n                generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n                originalLine: mapping.originalLine,\n                originalColumn: mapping.originalColumn,\n                name: name\n            };\n            this.__generatedMappings.push(adjustedMapping);\n            if (typeof adjustedMapping.originalLine === \"number\") {\n                this.__originalMappings.push(adjustedMapping);\n            }\n        }\n    }\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n};\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1qcy9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5Q0FBeUMsR0FDekM7Ozs7Q0FJQyxHQUVELElBQUlBLE9BQU9DLG1CQUFPQSxDQUFDO0FBQ25CLElBQUlDLGVBQWVELG1CQUFPQSxDQUFDO0FBQzNCLElBQUlFLFdBQVdGLHdHQUErQjtBQUM5QyxJQUFJRyxZQUFZSCxtQkFBT0EsQ0FBQztBQUN4QixJQUFJSSxZQUFZSiwyR0FBaUM7QUFFakQsU0FBU0ssa0JBQWtCQyxVQUFVLEVBQUVDLGFBQWE7SUFDbEQsSUFBSUMsWUFBWUY7SUFDaEIsSUFBSSxPQUFPQSxlQUFlLFVBQVU7UUFDbENFLFlBQVlULEtBQUtVLG1CQUFtQixDQUFDSDtJQUN2QztJQUVBLE9BQU9FLFVBQVVFLFFBQVEsSUFBSSxPQUN6QixJQUFJQyx5QkFBeUJILFdBQVdELGlCQUN4QyxJQUFJSyx1QkFBdUJKLFdBQVdEO0FBQzVDO0FBRUFGLGtCQUFrQlEsYUFBYSxHQUFHLFNBQVNQLFVBQVUsRUFBRUMsYUFBYTtJQUNsRSxPQUFPSyx1QkFBdUJDLGFBQWEsQ0FBQ1AsWUFBWUM7QUFDMUQ7QUFFQTs7Q0FFQyxHQUNERixrQkFBa0JTLFNBQVMsQ0FBQ0MsUUFBUSxHQUFHO0FBRXZDLDBFQUEwRTtBQUMxRSw4RUFBOEU7QUFDOUUscUVBQXFFO0FBQ3JFLDJFQUEyRTtBQUMzRSw4RUFBOEU7QUFDOUUsMkVBQTJFO0FBQzNFLDBEQUEwRDtBQUMxRCxFQUFFO0FBQ0YsNENBQTRDO0FBQzVDLEVBQUU7QUFDRixRQUFRO0FBQ1IsOERBQThEO0FBQzlELGtFQUFrRTtBQUNsRSx5RUFBeUU7QUFDekUsK0JBQStCO0FBQy9CLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsc0VBQXNFO0FBQ3RFLHFFQUFxRTtBQUNyRSw0RUFBNEU7QUFDNUUsb0JBQW9CO0FBQ3BCLFFBQVE7QUFDUixFQUFFO0FBQ0YseUVBQXlFO0FB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QUNqQ3NILENBQUFBLFFBQVFKLGVBQWUsQ0FBQ2xILGFBQWEsR0FBRztnQkFDM0NDLGlCQUFpQkwsUUFBUUssZUFBZSxHQUNyQ3FILENBQUFBLFFBQVFKLGVBQWUsQ0FBQ2xILGFBQWEsS0FBS0osUUFBUUksYUFBYSxHQUM5RHNILFFBQVFKLGVBQWUsQ0FBQ2pILGVBQWUsR0FBRyxJQUMxQztnQkFDSkMsY0FBY04sUUFBUU0sWUFBWTtnQkFDbENDLGdCQUFnQlAsUUFBUU8sY0FBYztnQkFDdENDLE1BQU1BO1lBQ1I7WUFFQSxJQUFJLENBQUNwRCxtQkFBbUIsQ0FBQ2dFLElBQUksQ0FBQ21IO1lBQzlCLElBQUksT0FBT0EsZ0JBQWdCakksWUFBWSxLQUFLLFVBQVU7Z0JBQ3BELElBQUksQ0FBQ3pDLGtCQUFrQixDQUFDdUQsSUFBSSxDQUFDbUg7WUFDL0I7UUFDRjtJQUNGO0lBRUEvTCxVQUFVLElBQUksQ0FBQ1ksbUJBQW1CLEVBQUVqQixLQUFLNkosbUNBQW1DO0lBQzVFeEosVUFBVSxJQUFJLENBQUNxQixrQkFBa0IsRUFBRTFCLEtBQUs4RSwwQkFBMEI7QUFDcEU7QUFFRkssZ0NBQWdDLEdBQUd2RSIsInNvdXJjZXMiOlsid2VicGFjazovL3dvcmtmbG93Ly4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtanMvbGliL3NvdXJjZS1tYXAtY29uc3VtZXIuanM/ZmE1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHF1aWNrU29ydCA9IHJlcXVpcmUoJy4vcXVpY2stc29ydCcpLnF1aWNrU29ydDtcblxuZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2VNYXAuc2VjdGlvbnMgIT0gbnVsbFxuICAgID8gbmV3IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpXG4gICAgOiBuZXcgQmFzaWNTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpO1xufVxuXG5Tb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID0gZnVuY3Rpb24oYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICByZXR1cm4gQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpO1xufVxuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLy8gYF9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZCBgX19vcmlnaW5hbE1hcHBpbmdzYCBhcmUgYXJyYXlzIHRoYXQgaG9sZCB0aGVcbi8vIHBhcnNlZCBtYXBwaW5nIGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZSBtYXAncyBcIm1hcHBpbmdzXCIgYXR0cmlidXRlLiBUaGV5XG4vLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgZ2V0dGVycyByZXNwZWN0aXZlbHksIGFuZCB3ZSBvbmx5IHBhcnNlIHRoZSBtYXBwaW5nc1xuLy8gYW5kIGNyZWF0ZSB0aGVzZSBhcnJheXMgb25jZSBxdWVyaWVkIGZvciBhIHNvdXJjZSBsb2NhdGlvbi4gV2UganVtcCB0aHJvdWdoXG4vLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbi8vIHRoZW0gaXMgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgaWYgd2UgbXVzdC5cbi8vXG4vLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuLy9cbi8vICAgICB7XG4vLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBzb3VyY2U6IFRoZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSB0aGF0IGdlbmVyYXRlZCB0aGlzXG4vLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgbmFtZTogVGhlIG5hbWUgb2YgdGhlIG9yaWdpbmFsIHN5bWJvbCB3aGljaCBnZW5lcmF0ZWQgdGhpcyBjaHVuayBvZlxuLy8gICAgICAgICAgICAgY29kZS5cbi8vICAgICB9XG4vL1xuLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuLy8gYG51bGxgLlxuLy9cbi8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4vL1xuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMuXG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfZ2VuZXJhdGVkTWFwcGluZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19vcmlnaW5hbE1hcHBpbmdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBpbmRleCkge1xuICAgIHZhciBjID0gYVN0ci5jaGFyQXQoaW5kZXgpO1xuICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzXCIpO1xuICB9O1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAqXG4gKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gKiBAcGFyYW0gYU9yZGVyXG4gKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgIHZhciBtYXBwaW5ncztcbiAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgdmFyIGJvdW5kQ2FsbGJhY2sgPSBhQ2FsbGJhY2suYmluZChjb250ZXh0KTtcbiAgICB2YXIgbmFtZXMgPSB0aGlzLl9uYW1lcztcbiAgICB2YXIgc291cmNlcyA9IHRoaXMuX3NvdXJjZXM7XG4gICAgdmFyIHNvdXJjZU1hcFVSTCA9IHRoaXMuX3NvdXJjZU1hcFVSTDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbWFwcGluZ3MubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlID09PSBudWxsID8gbnVsbCA6IHNvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgc291cmNlID0gdXRpbC5jb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHNvdXJjZSwgc291cmNlTWFwVVJMKTtcbiAgICAgIGJvdW5kQ2FsbGJhY2soe1xuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgbmFtZTogbWFwcGluZy5uYW1lID09PSBudWxsID8gbnVsbCA6IG5hbWVzLmF0KG1hcHBpbmcubmFtZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byBhIGVpdGhlciB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciBvciB0aGUgbmV4dFxuICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAqIG9yIHRoZSBuZXh0IGNsb3Nlc3QgY29sdW1uIHRoYXQgaGFzIGFueSBvZmZzZXRzLlxuICpcbiAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogT3B0aW9uYWwuIHRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IoYUFyZ3MpIHtcbiAgICB2YXIgbGluZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpO1xuXG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nXG4gICAgLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgbWFwcGluZyBsZXNzIHRoYW4gdGhlIG5lZWRsZS4gQnlcbiAgICAvLyBzZXR0aW5nIG5lZWRsZS5vcmlnaW5hbENvbHVtbiB0byAwLCB3ZSB0aHVzIGZpbmQgdGhlIGxhc3QgbWFwcGluZyBmb3JcbiAgICAvLyB0aGUgZ2l2ZW4gbGluZSwgcHJvdmlkZWQgc3VjaCBhIG1hcHBpbmcgZXhpc3RzLlxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICBvcmlnaW5hbExpbmU6IGxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nLCAwKVxuICAgIH07XG5cbiAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KG5lZWRsZS5zb3VyY2UpO1xuICAgIGlmIChuZWVkbGUuc291cmNlIDwgMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBtYXBwaW5ncyA9IFtdO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAoYUFyZ3MuY29sdW1uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2UgZm91bmQuIFNpbmNlXG4gICAgICAgIC8vIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgZm91bmQuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBvcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2Ugd2VyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICAvLyBTaW5jZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IGxpbmUgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPT0gb3JpZ2luYWxDb2x1bW4pIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBpbmdzO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICogcG9zaXRpb24gaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyB0aGUgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvclxuICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG5hbWVzOiBBbiBhcnJheSBvZiBpZGVudGlmaWVycyB3aGljaCBjYW4gYmUgcmVmZXJyZW5jZWQgYnkgaW5kaXZpZHVhbCBtYXBwaW5ncy5cbiAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBtYXBwaW5nczogQSBzdHJpbmcgb2YgYmFzZTY0IFZMUXMgd2hpY2ggY29udGFpbiB0aGUgYWN0dWFsIG1hcHBpbmdzLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqXG4gKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICpcbiAqICAgICB7XG4gKiAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgIGZpbGU6IFwib3V0LmpzXCIsXG4gKiAgICAgICBzb3VyY2VSb290IDogXCJcIixcbiAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgbWFwcGluZ3M6IFwiQUEsQUI7O0FCQ0RFO1wiXG4gKiAgICAgfVxuICpcbiAqIFRoZSBzZWNvbmQgcGFyYW1ldGVyLCBpZiBnaXZlbiwgaXMgYSBzdHJpbmcgd2hvc2UgdmFsdWUgaXMgdGhlIFVSTFxuICogYXQgd2hpY2ggdGhlIHNvdXJjZSBtYXAgd2FzIGZvdW5kLiAgVGhpcyBVUkwgaXMgdXNlZCB0byBjb21wdXRlIHRoZVxuICogc291cmNlcyBhcnJheS5cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAqL1xuZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gdXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlcycpO1xuICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gIC8vIHJlcXVpcmVzIHRoZSBhcnJheSkgdG8gcGxheSBuaWNlIGhlcmUuXG4gIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdmFyIHNvdXJjZXNDb250ZW50ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlc0NvbnRlbnQnLCBudWxsKTtcbiAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgLy8gT25jZSBhZ2FpbiwgU2FzcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGFuZCBzdXBwbGllcyB0aGUgdmVyc2lvbiBhcyBhXG4gIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VSb290KSB7XG4gICAgc291cmNlUm9vdCA9IHV0aWwubm9ybWFsaXplKHNvdXJjZVJvb3QpO1xuICB9XG5cbiAgc291cmNlcyA9IHNvdXJjZXNcbiAgICAubWFwKFN0cmluZylcbiAgICAvLyBTb21lIHNvdXJjZSBtYXBzIHByb2R1Y2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIGxpa2UgXCIuL2Zvby5qc1wiIGluc3RlYWQgb2ZcbiAgICAvLyBcImZvby5qc1wiLiAgTm9ybWFsaXplIHRoZXNlIGZpcnN0IHNvIHRoYXQgZnV0dXJlIGNvbXBhcmlzb25zIHdpbGwgc3VjY2VlZC5cbiAgICAvLyBTZWUgYnVnemlsLmxhLzEwOTA3NjguXG4gICAgLm1hcCh1dGlsLm5vcm1hbGl6ZSlcbiAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgYWJzb2x1dGUgc291cmNlcyBhcmUgaW50ZXJuYWxseSBzdG9yZWQgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgc291cmNlIHJvb3QsIGlmIHRoZSBzb3VyY2Ugcm9vdCBpcyBhYnNvbHV0ZS4gTm90IGRvaW5nIHRoaXMgd291bGRcbiAgICAvLyBiZSBwYXJ0aWN1bGFybHkgcHJvYmxlbWF0aWMgd2hlbiB0aGUgc291cmNlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlXG4gICAgLy8gc291cmNlICh2YWxpZCwgYnV0IHdoeT8/KS4gU2VlIGdpdGh1YiBpc3N1ZSAjMTk5IGFuZCBidWd6aWwubGEvMTE4ODk4Mi5cbiAgICAubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2VSb290ICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2VSb290KSAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlKVxuICAgICAgICA/IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlKVxuICAgICAgICA6IHNvdXJjZTtcbiAgICB9KTtcblxuICAvLyBQYXNzIGB0cnVlYCBiZWxvdyB0byBhbGxvdyBkdXBsaWNhdGUgbmFtZXMgYW5kIHNvdXJjZXMuIFdoaWxlIHNvdXJjZSBtYXBzXG4gIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gIC8vIHNvbWV0aW1lcyBnZW5lcmF0ZXMgc291cmNlIG1hcHMgd2l0aCBkdXBsaWNhdGVzIGluIHRoZW0uIFNlZSBHaXRodWIgaXNzdWVcbiAgLy8gIzcyIGFuZCBidWd6aWwubGEvODg5NDkyLlxuICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcy5tYXAoU3RyaW5nKSwgdHJ1ZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoc291cmNlcywgdHJ1ZSk7XG5cbiAgdGhpcy5fYWJzb2x1dGVTb3VyY2VzID0gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LCBzLCBhU291cmNlTWFwVVJMKTtcbiAgfSk7XG5cbiAgdGhpcy5zb3VyY2VSb290ID0gc291cmNlUm9vdDtcbiAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICB0aGlzLl9tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICB0aGlzLl9zb3VyY2VNYXBVUkwgPSBhU291cmNlTWFwVVJMO1xuICB0aGlzLmZpbGUgPSBmaWxlO1xufVxuXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBmaW5kIHRoZSBpbmRleCBvZiBhIHNvdXJjZS4gIFJldHVybnMgLTEgaWYgbm90XG4gKiBmb3VuZC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRTb3VyY2VJbmRleCA9IGZ1bmN0aW9uKGFTb3VyY2UpIHtcbiAgdmFyIHJlbGF0aXZlU291cmNlID0gYVNvdXJjZTtcbiAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgcmVsYXRpdmVTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgcmVsYXRpdmVTb3VyY2UpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKHJlbGF0aXZlU291cmNlKSkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLmluZGV4T2YocmVsYXRpdmVTb3VyY2UpO1xuICB9XG5cbiAgLy8gTWF5YmUgYVNvdXJjZSBpcyBhbiBhYnNvbHV0ZSBVUkwgYXMgcmV0dXJuZWQgYnkgfHNvdXJjZXN8LiAgSW5cbiAgLy8gdGhpcyBjYXNlIHdlIGNhbid0IHNpbXBseSB1bmRvIHRoZSB0cmFuc2Zvcm0uXG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYWJzb2x1dGVTb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHRoaXMuX2Fic29sdXRlU291cmNlc1tpXSA9PSBhU291cmNlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqXG4gKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG4gKiBAcGFyYW0gU3RyaW5nIGFTb3VyY2VNYXBVUkxcbiAqICAgICAgICBUaGUgVVJMIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIGNhbiBiZSBmb3VuZCAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICAgIHZhciBzbWMgPSBPYmplY3QuY3JlYXRlKEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgIHZhciBuYW1lcyA9IHNtYy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fbmFtZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICB2YXIgc291cmNlcyA9IHNtYy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgc21jLnNvdXJjZVJvb3QgPSBhU291cmNlTWFwLl9zb3VyY2VSb290O1xuICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYy5zb3VyY2VSb290KTtcbiAgICBzbWMuZmlsZSA9IGFTb3VyY2VNYXAuX2ZpbGU7XG4gICAgc21jLl9zb3VyY2VNYXBVUkwgPSBhU291cmNlTWFwVVJMO1xuICAgIHNtYy5fYWJzb2x1dGVTb3VyY2VzID0gc21jLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc21jLnNvdXJjZVJvb3QsIHMsIGFTb3VyY2VNYXBVUkwpO1xuICAgIH0pO1xuXG4gICAgLy8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuICAgIC8vIG5hbWVzIHRvIGluZGljZXMgaW50byB0aGUgc291cmNlcyBhbmQgbmFtZXMgQXJyYXlTZXRzKSwgd2UgaGF2ZSB0byBtYWtlXG4gICAgLy8gYSBjb3B5IG9mIHRoZSBlbnRyeSBvciBlbHNlIGJhZCB0aGluZ3MgaGFwcGVuLiBTaGFyZWQgbXV0YWJsZSBzdGF0ZVxuICAgIC8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cblxuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgIHZhciBkZXN0R2VuZXJhdGVkTWFwcGluZ3MgPSBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncyA9IHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNyY01hcHBpbmcgPSBnZW5lcmF0ZWRNYXBwaW5nc1tpXTtcbiAgICAgIHZhciBkZXN0TWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAoc3JjTWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgZGVzdE1hcHBpbmcuc291cmNlID0gc291cmNlcy5pbmRleE9mKHNyY01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxMaW5lID0gc3JjTWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gc3JjTWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAoc3JjTWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgZGVzdE1hcHBpbmcubmFtZSA9IG5hbWVzLmluZGV4T2Yoc3JjTWFwcGluZy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICBkZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHNtYy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNtYztcbiAgfTtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWJzb2x1dGVTb3VyY2VzLnNsaWNlKCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGUgdGhlIEpJVCB3aXRoIGEgbmljZSBzaGFwZSAvIGhpZGRlbiBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZygpIHtcbiAgdGhpcy5nZW5lcmF0ZWRMaW5lID0gMDtcbiAgdGhpcy5nZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHRoaXMubmFtZSA9IG51bGw7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5cbmNvbnN0IGNvbXBhcmVHZW5lcmF0ZWQgPSB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkTm9MaW5lO1xuZnVuY3Rpb24gc29ydEdlbmVyYXRlZChhcnJheSwgc3RhcnQpIHtcbiAgbGV0IGwgPSBhcnJheS5sZW5ndGg7XG4gIGxldCBuID0gYXJyYXkubGVuZ3RoIC0gc3RhcnQ7XG4gIGlmIChuIDw9IDEpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAobiA9PSAyKSB7XG4gICAgbGV0IGEgPSBhcnJheVtzdGFydF07XG4gICAgbGV0IGIgPSBhcnJheVtzdGFydCArIDFdO1xuICAgIGlmIChjb21wYXJlR2VuZXJhdGVkKGEsIGIpID4gMCkge1xuICAgICAgYXJyYXlbc3RhcnRdID0gYjtcbiAgICAgIGFycmF5W3N0YXJ0ICsgMV0gPSBhO1xuICAgIH1cbiAgfSBlbHNlIGlmIChuIDwgMjApIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBpOyBqID4gc3RhcnQ7IGotLSkge1xuICAgICAgICBsZXQgYSA9IGFycmF5W2ogLSAxXTtcbiAgICAgICAgbGV0IGIgPSBhcnJheVtqXTtcbiAgICAgICAgaWYgKGNvbXBhcmVHZW5lcmF0ZWQoYSwgYikgPD0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2ogLSAxXSA9IGI7XG4gICAgICAgIGFycmF5W2pdID0gYTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KGFycmF5LCBjb21wYXJlR2VuZXJhdGVkLCBzdGFydCk7XG4gIH1cbn1cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHZhciBnZW5lcmF0ZWRMaW5lID0gMTtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGFTdHIubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNhY2hlZFNlZ21lbnRzID0ge307XG4gICAgdmFyIHRlbXAgPSB7fTtcbiAgICB2YXIgb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBtYXBwaW5nLCBzdHIsIHNlZ21lbnQsIGVuZCwgdmFsdWU7XG5cbiAgICBsZXQgc3ViYXJyYXlTdGFydCA9IDA7XG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnOycpIHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAgICAgc29ydEdlbmVyYXRlZChnZW5lcmF0ZWRNYXBwaW5ncywgc3ViYXJyYXlTdGFydCk7XG4gICAgICAgIHN1YmFycmF5U3RhcnQgPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICcsJykge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgIGZvciAoZW5kID0gaW5kZXg7IGVuZCA8IGxlbmd0aDsgZW5kKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5fY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBlbmQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gYVN0ci5zbGljZShpbmRleCwgZW5kKTtcblxuICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGVuZCkge1xuICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoYVN0ciwgaW5kZXgsIHRlbXApO1xuICAgICAgICAgIHZhbHVlID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICBpbmRleCA9IHRlbXAucmVzdDtcbiAgICAgICAgICBzZWdtZW50LnB1c2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSwgYnV0IG5vIGxpbmUgYW5kIGNvbHVtbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSBhbmQgbGluZSwgYnV0IG5vIGNvbHVtbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGVkIGNvbHVtbi5cbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiArIHNlZ21lbnRbMF07XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gMSkge1xuICAgICAgICAgIC8vIE9yaWdpbmFsIHNvdXJjZS5cbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHByZXZpb3VzU291cmNlICsgc2VnbWVudFsxXTtcbiAgICAgICAgICBwcmV2aW91c1NvdXJjZSArPSBzZWdtZW50WzFdO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgbGluZS5cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IHByZXZpb3VzT3JpZ2luYWxMaW5lICsgc2VnbWVudFsyXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICAgIC8vIExpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZFxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lICs9IDE7XG5cbiAgICAgICAgICAvLyBPcmlnaW5hbCBjb2x1bW4uXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gKyBzZWdtZW50WzNdO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgLy8gT3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IHByZXZpb3VzTmFtZSArIHNlZ21lbnRbNF07XG4gICAgICAgICAgICBwcmV2aW91c05hbWUgKz0gc2VnbWVudFs0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGxldCBjdXJyZW50U291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgICAgd2hpbGUgKG9yaWdpbmFsTWFwcGluZ3MubGVuZ3RoIDw9IGN1cnJlbnRTb3VyY2UpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTWFwcGluZ3MucHVzaChudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9yaWdpbmFsTWFwcGluZ3NbY3VycmVudFNvdXJjZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTWFwcGluZ3NbY3VycmVudFNvdXJjZV0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3JpZ2luYWxNYXBwaW5nc1tjdXJyZW50U291cmNlXS5wdXNoKG1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc29ydEdlbmVyYXRlZChnZW5lcmF0ZWRNYXBwaW5ncywgc3ViYXJyYXlTdGFydCk7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gZ2VuZXJhdGVkTWFwcGluZ3M7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yaWdpbmFsTWFwcGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvcmlnaW5hbE1hcHBpbmdzW2ldICE9IG51bGwpIHtcbiAgICAgICAgcXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3NbaV0sIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnNOb1NvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW10uY29uY2F0KC4uLm9yaWdpbmFsTWFwcGluZ3MpO1xuICB9O1xuXG4vKipcbiAqIEZpbmQgdGhlIG1hcHBpbmcgdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGh5cG90aGV0aWNhbCBcIm5lZWRsZVwiIG1hcHBpbmcgdGhhdFxuICogd2UgYXJlIHNlYXJjaGluZyBmb3IgaW4gdGhlIGdpdmVuIFwiaGF5c3RhY2tcIiBvZiBtYXBwaW5ncy5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZmluZE1hcHBpbmcoYU5lZWRsZSwgYU1hcHBpbmdzLCBhTGluZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb2x1bW5OYW1lLCBhQ29tcGFyYXRvciwgYUJpYXMpIHtcbiAgICAvLyBUbyByZXR1cm4gdGhlIHBvc2l0aW9uIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCB3ZSBtdXN0IGZpcnN0IGZpbmQgdGhlXG4gICAgLy8gbWFwcGluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgb3Bwb3NpdGUgcG9zaXRpb24gaXRcbiAgICAvLyBwb2ludHMgdG8uIEJlY2F1c2UgdGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHdlIGNhbiB1c2UgYmluYXJ5IHNlYXJjaCB0b1xuICAgIC8vIGZpbmQgdGhlIGJlc3QgbWFwcGluZy5cblxuICAgIGlmIChhTmVlZGxlW2FMaW5lTmFtZV0gPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTGluZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUxpbmVOYW1lXSk7XG4gICAgfVxuICAgIGlmIChhTmVlZGxlW2FDb2x1bW5OYW1lXSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbHVtbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUNvbHVtbk5hbWVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmluYXJ5U2VhcmNoLnNlYXJjaChhTmVlZGxlLCBhTWFwcGluZ3MsIGFDb21wYXJhdG9yLCBhQmlhcyk7XG4gIH07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbGFzdCBjb2x1bW4gZm9yIGVhY2ggZ2VuZXJhdGVkIG1hcHBpbmcuIFRoZSBsYXN0IGNvbHVtbiBpc1xuICogaW5jbHVzaXZlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb21wdXRlQ29sdW1uU3BhbnMgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jb21wdXRlQ29sdW1uU3BhbnMoKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIC8vIE1hcHBpbmdzIGRvIG5vdCBjb250YWluIGEgZmllbGQgZm9yIHRoZSBsYXN0IGdlbmVyYXRlZCBjb2x1bW50LiBXZVxuICAgICAgLy8gY2FuIGNvbWUgdXAgd2l0aCBhbiBvcHRpbWlzdGljIGVzdGltYXRlLCBob3dldmVyLCBieSBhc3N1bWluZyB0aGF0XG4gICAgICAvLyBtYXBwaW5ncyBhcmUgY29udGlndW91cyAoaS5lLiBnaXZlbiB0d28gY29uc2VjdXRpdmUgbWFwcGluZ3MsIHRoZVxuICAgICAgLy8gZmlyc3QgbWFwcGluZyBlbmRzIHdoZXJlIHRoZSBzZWNvbmQgb25lIHN0YXJ0cykuXG4gICAgICBpZiAoaW5kZXggKyAxIDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXh0TWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4ICsgMV07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IG5leHRNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtIDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGxhc3QgbWFwcGluZyBmb3IgZWFjaCBsaW5lIHNwYW5zIHRoZSBlbnRpcmUgbGluZS5cbiAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IEluZmluaXR5O1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgIG5lZWRsZSxcbiAgICAgIHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLFxuICAgICAgXCJnZW5lcmF0ZWRMaW5lXCIsXG4gICAgICBcImdlbmVyYXRlZENvbHVtblwiLFxuICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCxcbiAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnc291cmNlJywgbnVsbCk7XG4gICAgICAgIGlmIChzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmF0KHNvdXJjZSk7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5jb21wdXRlU291cmNlVVJMKHRoaXMuc291cmNlUm9vdCwgc291cmNlLCB0aGlzLl9zb3VyY2VNYXBVUkwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ25hbWUnLCBudWxsKTtcbiAgICAgICAgaWYgKG5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuYXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBuYW1lOiBudWxsXG4gICAgfTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gIGZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+PSB0aGlzLl9zb3VyY2VzLnNpemUoKSAmJlxuICAgICAgIXRoaXMuc291cmNlc0NvbnRlbnQuc29tZShmdW5jdGlvbiAoc2MpIHsgcmV0dXJuIHNjID09IG51bGw7IH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kU291cmNlSW5kZXgoYVNvdXJjZSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W2luZGV4XTtcbiAgICB9XG5cbiAgICB2YXIgcmVsYXRpdmVTb3VyY2UgPSBhU291cmNlO1xuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgcmVsYXRpdmVTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgcmVsYXRpdmVTb3VyY2UpO1xuICAgIH1cblxuICAgIHZhciB1cmw7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsXG4gICAgICAgICYmICh1cmwgPSB1dGlsLnVybFBhcnNlKHRoaXMuc291cmNlUm9vdCkpKSB7XG4gICAgICAvLyBYWFg6IGZpbGU6Ly8gVVJJcyBhbmQgYWJzb2x1dGUgcGF0aHMgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGZvclxuICAgICAgLy8gbWFueSB1c2Vycy4gV2UgY2FuIGhlbHAgdGhlbSBvdXQgd2hlbiB0aGV5IGV4cGVjdCBmaWxlOi8vIFVSSXMgdG9cbiAgICAgIC8vIGJlaGF2ZSBsaWtlIGl0IHdvdWxkIGlmIHRoZXkgd2VyZSBydW5uaW5nIGEgbG9jYWwgSFRUUCBzZXJ2ZXIuIFNlZVxuICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg1NTk3LlxuICAgICAgdmFyIGZpbGVVcmlBYnNQYXRoID0gcmVsYXRpdmVTb3VyY2UucmVwbGFjZSgvXmZpbGU6XFwvXFwvLywgXCJcIik7XG4gICAgICBpZiAodXJsLnNjaGVtZSA9PSBcImZpbGVcIlxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKGZpbGVVcmlBYnNQYXRoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoZmlsZVVyaUFic1BhdGgpXVxuICAgICAgfVxuXG4gICAgICBpZiAoKCF1cmwucGF0aCB8fCB1cmwucGF0aCA9PSBcIi9cIilcbiAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhcIi9cIiArIHJlbGF0aXZlU291cmNlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoXCIvXCIgKyByZWxhdGl2ZVNvdXJjZSldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSBmcm9tXG4gICAgLy8gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yLiBJbiB0aGF0IGNhc2UsIHdlXG4gICAgLy8gZG9uJ3Qgd2FudCB0byB0aHJvdyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBzb3VyY2UgLSB3ZSBqdXN0IHdhbnQgdG9cbiAgICAvLyByZXR1cm4gbnVsbCwgc28gd2UgcHJvdmlkZSBhIGZsYWcgdG8gZXhpdCBncmFjZWZ1bGx5LlxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIHJlbGF0aXZlU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpO1xuICAgIHNvdXJjZSA9IHRoaXMuX2ZpbmRTb3VyY2VJbmRleChzb3VyY2UpO1xuICAgIGlmIChzb3VyY2UgPCAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgb3JpZ2luYWxMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IG5lZWRsZS5zb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG5leHBvcnRzLkJhc2ljU291cmNlTWFwQ29uc3VtZXIgPSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIEFuIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2hcbiAqIHdlIGNhbiBxdWVyeSBmb3IgaW5mb3JtYXRpb24uIEl0IGRpZmZlcnMgZnJvbSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluXG4gKiB0aGF0IGl0IHRha2VzIFwiaW5kZXhlZFwiIHNvdXJjZSBtYXBzIChpLmUuIG9uZXMgd2l0aCBhIFwic2VjdGlvbnNcIiBmaWVsZCkgYXNcbiAqIGlucHV0LlxuICpcbiAqIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgYSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yIGFscmVhZHlcbiAqIHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMgZm9yIGluZGV4ZWQgc291cmNlIG1hcHMsIHRoZXlcbiAqIGhhdmUgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqICAgLSBzZWN0aW9uczogQSBsaXN0IG9mIHNlY3Rpb24gZGVmaW5pdGlvbnMuXG4gKlxuICogRWFjaCB2YWx1ZSB1bmRlciB0aGUgXCJzZWN0aW9uc1wiIGZpZWxkIGhhcyB0d28gZmllbGRzOlxuICogICAtIG9mZnNldDogVGhlIG9mZnNldCBpbnRvIHRoZSBvcmlnaW5hbCBzcGVjaWZpZWQgYXQgd2hpY2ggdGhpcyBzZWN0aW9uXG4gKiAgICAgICBiZWdpbnMgdG8gYXBwbHksIGRlZmluZWQgYXMgYW4gb2JqZWN0IHdpdGggYSBcImxpbmVcIiBhbmQgXCJjb2x1bW5cIlxuICogICAgICAgZmllbGQuXG4gKiAgIC0gbWFwOiBBIHNvdXJjZSBtYXAgZGVmaW5pdGlvbi4gVGhpcyBzb3VyY2UgbWFwIGNvdWxkIGFsc28gYmUgaW5kZXhlZCxcbiAqICAgICAgIGJ1dCBkb2Vzbid0IGhhdmUgdG8gYmUuXG4gKlxuICogSW5zdGVhZCBvZiB0aGUgXCJtYXBcIiBmaWVsZCwgaXQncyBhbHNvIHBvc3NpYmxlIHRvIGhhdmUgYSBcInVybFwiIGZpZWxkXG4gKiBzcGVjaWZ5aW5nIGEgVVJMIHRvIHJldHJpZXZlIGEgc291cmNlIG1hcCBmcm9tLCBidXQgdGhhdCdzIGN1cnJlbnRseVxuICogdW5zdXBwb3J0ZWQuXG4gKlxuICogSGVyZSdzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdLCBidXRcbiAqIG1vZGlmaWVkIHRvIG9taXQgYSBzZWN0aW9uIHdoaWNoIHVzZXMgdGhlIFwidXJsXCIgZmllbGQuXG4gKlxuICogIHtcbiAqICAgIHZlcnNpb24gOiAzLFxuICogICAgZmlsZTogXCJhcHAuanNcIixcbiAqICAgIHNlY3Rpb25zOiBbe1xuICogICAgICBvZmZzZXQ6IHtsaW5lOjEwMCwgY29sdW1uOjEwfSxcbiAqICAgICAgbWFwOiB7XG4gKiAgICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICAgZmlsZTogXCJzZWN0aW9uLmpzXCIsXG4gKiAgICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICogICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgIG1hcHBpbmdzOiBcIkFBQUEsRTs7QUJDREU7XCJcbiAqICAgICAgfVxuICogICAgfV0sXG4gKiAgfVxuICpcbiAqIFRoZSBzZWNvbmQgcGFyYW1ldGVyLCBpZiBnaXZlbiwgaXMgYSBzdHJpbmcgd2hvc2UgdmFsdWUgaXMgdGhlIFVSTFxuICogYXQgd2hpY2ggdGhlIHNvdXJjZSBtYXAgd2FzIGZvdW5kLiAgVGhpcyBVUkwgaXMgdXNlZCB0byBjb21wdXRlIHRoZVxuICogc291cmNlcyBhcnJheS5cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdCNoZWFkaW5nPWguNTM1ZXMzeGVwcmd0XG4gKi9cbmZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gdXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzZWN0aW9ucyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NlY3Rpb25zJyk7XG5cbiAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICB9XG5cbiAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gIHZhciBsYXN0T2Zmc2V0ID0ge1xuICAgIGxpbmU6IC0xLFxuICAgIGNvbHVtbjogMFxuICB9O1xuICB0aGlzLl9zZWN0aW9ucyA9IHNlY3Rpb25zLm1hcChmdW5jdGlvbiAocykge1xuICAgIGlmIChzLnVybCkge1xuICAgICAgLy8gVGhlIHVybCBmaWVsZCB3aWxsIHJlcXVpcmUgc3VwcG9ydCBmb3IgYXN5bmNocm9uaWNpdHkuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMTZcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcG9ydCBmb3IgdXJsIGZpZWxkIGluIHNlY3Rpb25zIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IHV0aWwuZ2V0QXJnKHMsICdvZmZzZXQnKTtcbiAgICB2YXIgb2Zmc2V0TGluZSA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2xpbmUnKTtcbiAgICB2YXIgb2Zmc2V0Q29sdW1uID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnY29sdW1uJyk7XG5cbiAgICBpZiAob2Zmc2V0TGluZSA8IGxhc3RPZmZzZXQubGluZSB8fFxuICAgICAgICAob2Zmc2V0TGluZSA9PT0gbGFzdE9mZnNldC5saW5lICYmIG9mZnNldENvbHVtbiA8IGxhc3RPZmZzZXQuY29sdW1uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWN0aW9uIG9mZnNldHMgbXVzdCBiZSBvcmRlcmVkIGFuZCBub24tb3ZlcmxhcHBpbmcuJyk7XG4gICAgfVxuICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2VuZXJhdGVkT2Zmc2V0OiB7XG4gICAgICAgIC8vIFRoZSBvZmZzZXQgZmllbGRzIGFyZSAwLWJhc2VkLCBidXQgd2UgdXNlIDEtYmFzZWQgaW5kaWNlcyB3aGVuXG4gICAgICAgIC8vIGVuY29kaW5nL2RlY29kaW5nIGZyb20gVkxRLlxuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBvZmZzZXRMaW5lICsgMSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBvZmZzZXRDb2x1bW4gKyAxXG4gICAgICB9LFxuICAgICAgY29uc3VtZXI6IG5ldyBTb3VyY2VNYXBDb25zdW1lcih1dGlsLmdldEFyZyhzLCAnbWFwJyksIGFTb3VyY2VNYXBVUkwpXG4gICAgfVxuICB9KTtcbn1cblxuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc291cmNlcy5wdXNoKHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXNbal0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlcztcbiAgfVxufSk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgLy8gRmluZCB0aGUgc2VjdGlvbiBjb250YWluaW5nIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24gd2UncmUgdHJ5aW5nIHRvIG1hcFxuICAgIC8vIHRvIGFuIG9yaWdpbmFsIHBvc2l0aW9uLlxuICAgIHZhciBzZWN0aW9uSW5kZXggPSBiaW5hcnlTZWFyY2guc2VhcmNoKG5lZWRsZSwgdGhpcy5fc2VjdGlvbnMsXG4gICAgICBmdW5jdGlvbihuZWVkbGUsIHNlY3Rpb24pIHtcbiAgICAgICAgdmFyIGNtcCA9IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC0gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZTtcbiAgICAgICAgaWYgKGNtcCkge1xuICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbik7XG4gICAgICB9KTtcbiAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW3NlY3Rpb25JbmRleF07XG5cbiAgICBpZiAoIXNlY3Rpb24pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBuYW1lOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBzZWN0aW9uLmNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgbGluZTogbmVlZGxlLmdlbmVyYXRlZExpbmUgLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgY29sdW1uOiBuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgIDogMCksXG4gICAgICBiaWFzOiBhQXJncy5iaWFzXG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VjdGlvbnMuZXZlcnkoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiBzLmNvbnN1bWVyLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCk7XG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICB2YXIgY29udGVudCA9IHNlY3Rpb24uY29uc3VtZXIuc291cmNlQ29udGVudEZvcihhU291cmNlLCB0cnVlKTtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLiBcbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICAvLyBPbmx5IGNvbnNpZGVyIHRoaXMgc2VjdGlvbiBpZiB0aGUgcmVxdWVzdGVkIHNvdXJjZSBpcyBpbiB0aGUgbGlzdCBvZlxuICAgICAgLy8gc291cmNlcyBvZiB0aGUgY29uc3VtZXIuXG4gICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5fZmluZFNvdXJjZUluZGV4KHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJykpID09PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBnZW5lcmF0ZWRQb3NpdGlvbiA9IHNlY3Rpb24uY29uc3VtZXIuZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpO1xuICAgICAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uKSB7XG4gICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgbGluZTogZ2VuZXJhdGVkUG9zaXRpb24ubGluZSArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkUG9zaXRpb24uY29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lXG4gICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICAgOiAwKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsXG4gICAgfTtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcbiAgICAgIHZhciBzZWN0aW9uTWFwcGluZ3MgPSBzZWN0aW9uLmNvbnN1bWVyLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VjdGlvbk1hcHBpbmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gc2VjdGlvbk1hcHBpbmdzW2pdO1xuXG4gICAgICAgIHZhciBzb3VyY2UgPSBzZWN0aW9uLmNvbnN1bWVyLl9zb3VyY2VzLmF0KG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgc291cmNlID0gdXRpbC5jb21wdXRlU291cmNlVVJMKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCwgc291cmNlLCB0aGlzLl9zb3VyY2VNYXBVUkwpO1xuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgICAgICB2YXIgbmFtZSA9IG51bGw7XG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUpIHtcbiAgICAgICAgICBuYW1lID0gc2VjdGlvbi5jb25zdW1lci5fbmFtZXMuYXQobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgbWFwcGluZ3MgY29taW5nIGZyb20gdGhlIGNvbnN1bWVyIGZvciB0aGUgc2VjdGlvbiBoYXZlXG4gICAgICAgIC8vIGdlbmVyYXRlZCBwb3NpdGlvbnMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBzZWN0aW9uLCBzbyB3ZVxuICAgICAgICAvLyBuZWVkIHRvIG9mZnNldCB0aGVtIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgY29uY2F0ZW5hdGVkXG4gICAgICAgIC8vIGdlbmVyYXRlZCBmaWxlLlxuICAgICAgICB2YXIgYWRqdXN0ZWRNYXBwaW5nID0ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG1hcHBpbmcuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICA6IDApLFxuICAgICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYWRqdXN0ZWRNYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQodGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICBxdWlja1NvcnQodGhpcy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICB9O1xuXG5leHBvcnRzLkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciA9IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcjtcbiJdLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsImJpbmFyeVNlYXJjaCIsIkFycmF5U2V0IiwiYmFzZTY0VkxRIiwicXVpY2tTb3J0IiwiU291cmNlTWFwQ29uc3VtZXIiLCJhU291cmNlTWFwIiwiYVNvdXJjZU1hcFVSTCIsInNvdXJjZU1hcCIsInBhcnNlU291cmNlTWFwSW5wdXQiLCJzZWN0aW9ucyIsIkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciIsIkJhc2ljU291cmNlTWFwQ29uc3VtZXIiLCJmcm9tU291cmNlTWFwIiwicHJvdG90eXBlIiwiX3ZlcnNpb24iLCJfX2dlbmVyYXRlZE1hcHBpbmdzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX3BhcnNlTWFwcGluZ3MiLCJfbWFwcGluZ3MiLCJzb3VyY2VSb290IiwiX19vcmlnaW5hbE1hcHBpbmdzIiwiX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IiLCJTb3VyY2VNYXBDb25zdW1lcl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yIiwiYVN0ciIsImluZGV4IiwiYyIsImNoYXJBdCIsIlNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MiLCJhU291cmNlUm9vdCIsIkVycm9yIiwiR0VORVJBVEVEX09SREVSIiwiT1JJR0lOQUxfT1JERVIiLCJHUkVBVEVTVF9MT1dFUl9CT1VORCIsIkxFQVNUX1VQUEVSX0JPVU5EIiwiZWFjaE1hcHBpbmciLCJTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyIsImFDYWxsYmFjayIsImFDb250ZXh0IiwiYU9yZGVyIiwiY29udGV4dCIsIm9yZGVyIiwibWFwcGluZ3MiLCJfZ2VuZXJhdGVkTWFwcGluZ3MiLCJfb3JpZ2luYWxNYXBwaW5ncyIsImJvdW5kQ2FsbGJhY2siLCJiaW5kIiwibmFtZXMiLCJfbmFtZXMiLCJzb3VyY2VzIiwiX3NvdXJjZXMiLCJzb3VyY2VNYXBVUkwiLCJfc291cmNlTWFwVVJMIiwiaSIsIm4iLCJsZW5ndGgiLCJtYXBwaW5nIiwic291cmNlIiwiYXQiLCJjb21wdXRlU291cmNlVVJMIiwiZ2VuZXJhdGVkTGluZSIsImdlbmVyYXRlZENvbHVtbiIsIm9yaWdpbmFsTGluZSIsIm9yaWdpbmFsQ29sdW1uIiwibmFtZSIsImFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciIsIlNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciIsImFBcmdzIiwibGluZSIsImdldEFyZyIsIm5lZWRsZSIsIl9maW5kU291cmNlSW5kZXgiLCJfZmluZE1hcHBpbmciLCJjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyIsImNvbHVtbiIsInVuZGVmaW5lZCIsInB1c2giLCJsYXN0Q29sdW1uIiwiZXhwb3J0cyIsInZlcnNpb24iLCJzb3VyY2VzQ29udGVudCIsImZpbGUiLCJub3JtYWxpemUiLCJtYXAiLCJTdHJpbmciLCJpc0Fic29sdXRlIiwicmVsYXRpdmUiLCJmcm9tQXJyYXkiLCJfYWJzb2x1dGVTb3VyY2VzIiwidG9BcnJheSIsInMiLCJjcmVhdGUiLCJjb25zdW1lciIsImFTb3VyY2UiLCJyZWxhdGl2ZVNvdXJjZSIsImhhcyIsImluZGV4T2YiLCJTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwIiwic21jIiwiX3NvdXJjZVJvb3QiLCJfZ2VuZXJhdGVTb3VyY2VzQ29udGVudCIsIl9maWxlIiwiZ2VuZXJhdGVkTWFwcGluZ3MiLCJzbGljZSIsImRlc3RHZW5lcmF0ZWRNYXBwaW5ncyIsImRlc3RPcmlnaW5hbE1hcHBpbmdzIiwic3JjTWFwcGluZyIsImRlc3RNYXBwaW5nIiwiTWFwcGluZyIsImNvbXBhcmVHZW5lcmF0ZWQiLCJjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZE5vTGluZSIsInNvcnRHZW5lcmF0ZWQiLCJhcnJheSIsInN0YXJ0IiwibCIsImEiLCJiIiwiaiIsInByZXZpb3VzR2VuZXJhdGVkQ29sdW1uIiwicHJldmlvdXNPcmlnaW5hbExpbmUiLCJwcmV2aW91c09yaWdpbmFsQ29sdW1uIiwicHJldmlvdXNTb3VyY2UiLCJwcmV2aW91c05hbWUiLCJjYWNoZWRTZWdtZW50cyIsInRlbXAiLCJvcmlnaW5hbE1hcHBpbmdzIiwic3RyIiwic2VnbWVudCIsImVuZCIsInZhbHVlIiwic3ViYXJyYXlTdGFydCIsImRlY29kZSIsInJlc3QiLCJjdXJyZW50U291cmNlIiwiY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnNOb1NvdXJjZSIsImNvbmNhdCIsIlNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nIiwiYU5lZWRsZSIsImFNYXBwaW5ncyIsImFMaW5lTmFtZSIsImFDb2x1bW5OYW1lIiwiYUNvbXBhcmF0b3IiLCJhQmlhcyIsIlR5cGVFcnJvciIsInNlYXJjaCIsImNvbXB1dGVDb2x1bW5TcGFucyIsIlNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucyIsIm5leHRNYXBwaW5nIiwibGFzdEdlbmVyYXRlZENvbHVtbiIsIkluZmluaXR5Iiwib3JpZ2luYWxQb3NpdGlvbkZvciIsIlNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IiLCJjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCIsImhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzIiwiQmFzaWNTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcyIsInNpemUiLCJzb21lIiwic2MiLCJzb3VyY2VDb250ZW50Rm9yIiwiU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvciIsIm51bGxPbk1pc3NpbmciLCJ1cmwiLCJ1cmxQYXJzZSIsImZpbGVVcmlBYnNQYXRoIiwicmVwbGFjZSIsInNjaGVtZSIsInBhdGgiLCJnZW5lcmF0ZWRQb3NpdGlvbkZvciIsIlNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yIiwibGFzdE9mZnNldCIsIl9zZWN0aW9ucyIsIm9mZnNldCIsIm9mZnNldExpbmUiLCJvZmZzZXRDb2x1bW4iLCJnZW5lcmF0ZWRPZmZzZXQiLCJjb25zdHJ1Y3RvciIsIkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yIiwic2VjdGlvbkluZGV4Iiwic2VjdGlvbiIsImNtcCIsImJpYXMiLCJJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMiLCJldmVyeSIsIkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yIiwiY29udGVudCIsIkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvciIsImdlbmVyYXRlZFBvc2l0aW9uIiwicmV0IiwiSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MiLCJzZWN0aW9uTWFwcGluZ3MiLCJhZGQiLCJhZGp1c3RlZE1hcHBpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/source-map-js/lib/source-map-consumer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/source-map-js/lib/source-map-generator.js":
/*!****************************************************************!*\
  !*** ./node_modules/source-map-js/lib/source-map-generator.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var base64VLQ = __webpack_require__(/*! ./base64-vlq */ \"(ssr)/./node_modules/source-map-js/lib/base64-vlq.js\");\nvar util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/source-map-js/lib/util.js\");\nvar ArraySet = (__webpack_require__(/*! ./array-set */ \"(ssr)/./node_modules/source-map-js/lib/array-set.js\").ArraySet);\nvar MappingList = (__webpack_require__(/*! ./mapping-list */ \"(ssr)/./node_modules/source-map-js/lib/mapping-list.js\").MappingList);\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */ function SourceMapGenerator(aArgs) {\n    if (!aArgs) {\n        aArgs = {};\n    }\n    this._file = util.getArg(aArgs, \"file\", null);\n    this._sourceRoot = util.getArg(aArgs, \"sourceRoot\", null);\n    this._skipValidation = util.getArg(aArgs, \"skipValidation\", false);\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n    this._mappings = new MappingList();\n    this._sourcesContents = null;\n}\nSourceMapGenerator.prototype._version = 3;\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */ SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n        file: aSourceMapConsumer.file,\n        sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function(mapping) {\n        var newMapping = {\n            generated: {\n                line: mapping.generatedLine,\n                column: mapping.generatedColumn\n            }\n        };\n        if (mapping.source != null) {\n            newMapping.source = mapping.source;\n            if (sourceRoot != null) {\n                newMapping.source = util.relative(sourceRoot, newMapping.source);\n            }\n            newMapping.original = {\n                line: mapping.originalLine,\n                column: mapping.originalColumn\n            };\n            if (mapping.name != null) {\n                newMapping.name = mapping.name;\n            }\n        }\n        generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n        var sourceRelative = sourceFile;\n        if (sourceRoot !== null) {\n            sourceRelative = util.relative(sourceRoot, sourceFile);\n        }\n        if (!generator._sources.has(sourceRelative)) {\n            generator._sources.add(sourceRelative);\n        }\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n            generator.setSourceContent(sourceFile, content);\n        }\n    });\n    return generator;\n};\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */ SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, \"generated\");\n    var original = util.getArg(aArgs, \"original\", null);\n    var source = util.getArg(aArgs, \"source\", null);\n    var name = util.getArg(aArgs, \"name\", null);\n    if (!this._skipValidation) {\n        this._validateMapping(generated, original, source, name);\n    }\n    if (source != null) {\n        source = String(source);\n        if (!this._sources.has(source)) {\n            this._sources.add(source);\n        }\n    }\n    if (name != null) {\n        name = String(name);\n        if (!this._names.has(name)) {\n            this._names.add(name);\n        }\n    }\n    this._mappings.add({\n        generatedLine: generated.line,\n        generatedColumn: generated.column,\n        originalLine: original != null && original.line,\n        originalColumn: original != null && original.column,\n        source: source,\n        name: name\n    });\n};\n/**\n * Set the source content for a source file.\n */ SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n        source = util.relative(this._sourceRoot, source);\n    }\n    if (aSourceContent != null) {\n        // Add the source content to the _sourcesContents map.\n        // Create a new _sourcesContents map if the property is null.\n        if (!this._sourcesContents) {\n            this._sourcesContents = Object.create(null);\n        }\n        this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n        // Remove the source file from the _sourcesContents map.\n        // If the _sourcesContents map is empty, set the property to null.\n        delete this._sourcesContents[util.toSetString(source)];\n        if (Object.keys(this._sourcesContents).length === 0) {\n            this._sourcesContents = null;\n        }\n    }\n};\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */ SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n        if (aSourceMapConsumer.file == null) {\n            throw new Error(\"SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, \" + 'or the source map\\'s \"file\" property. Both were omitted.');\n        }\n        sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n        sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function(mapping) {\n        if (mapping.source === sourceFile && mapping.originalLine != null) {\n            // Check if it can be mapped by the source map, then update the mapping.\n            var original = aSourceMapConsumer.originalPositionFor({\n                line: mapping.originalLine,\n                column: mapping.originalColumn\n            });\n            if (original.source != null) {\n                // Copy mapping\n                mapping.source = original.source;\n                if (aSourceMapPath != null) {\n                    mapping.source = util.join(aSourceMapPath, mapping.source);\n                }\n                if (sourceRoot != null) {\n                    mapping.source = util.relative(sourceRoot, mapping.source);\n                }\n                mapping.originalLine = original.line;\n                mapping.originalColumn = original.column;\n                if (original.name != null) {\n                    mapping.name = original.name;\n                }\n            }\n        }\n        var source = mapping.source;\n        if (source != null && !newSources.has(source)) {\n            newSources.add(source);\n        }\n        var name = mapping.name;\n        if (name != null && !newNames.has(name)) {\n            newNames.add(name);\n        }\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n            if (aSourceMapPath != null) {\n                sourceFile = util.join(aSourceMapPath, sourceFile);\n            }\n            if (sourceRoot != null) {\n                sourceFile = util.relative(sourceRoot, sourceFile);\n            }\n            this.setSourceContent(sourceFile, content);\n        }\n    }, this);\n};\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */ SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== \"number\" && typeof aOriginal.column !== \"number\") {\n        throw new Error(\"original.line and original.column are not numbers -- you probably meant to omit \" + \"the original mapping entirely and only map the generated position. If so, pass \" + \"null for the original mapping instead of an object with empty or null values.\");\n    }\n    if (aGenerated && \"line\" in aGenerated && \"column\" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {\n        // Case 1.\n        return;\n    } else if (aGenerated && \"line\" in aGenerated && \"column\" in aGenerated && aOriginal && \"line\" in aOriginal && \"column\" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {\n        // Cases 2 and 3.\n        return;\n    } else {\n        throw new Error(\"Invalid mapping: \" + JSON.stringify({\n            generated: aGenerated,\n            source: aSource,\n            original: aOriginal,\n            name: aName\n        }));\n    }\n};\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */ SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = \"\";\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n    var mappings = this._mappings.toArray();\n    for(var i = 0, len = mappings.length; i < len; i++){\n        mapping = mappings[i];\n        next = \"\";\n        if (mapping.generatedLine !== previousGeneratedLine) {\n            previousGeneratedColumn = 0;\n            while(mapping.generatedLine !== previousGeneratedLine){\n                next += \";\";\n                previousGeneratedLine++;\n            }\n        } else {\n            if (i > 0) {\n                if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n                    continue;\n                }\n                next += \",\";\n            }\n        }\n        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);\n        previousGeneratedColumn = mapping.generatedColumn;\n        if (mapping.source != null) {\n            sourceIdx = this._sources.indexOf(mapping.source);\n            next += base64VLQ.encode(sourceIdx - previousSource);\n            previousSource = sourceIdx;\n            // lines are stored 0-based in SourceMap spec version 3\n            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);\n            previousOriginalLine = mapping.originalLine - 1;\n            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);\n            previousOriginalColumn = mapping.originalColumn;\n            if (mapping.name != null) {\n                nameIdx = this._names.indexOf(mapping.name);\n                next += base64VLQ.encode(nameIdx - previousName);\n                previousName = nameIdx;\n            }\n        }\n        result += next;\n    }\n    return result;\n};\nSourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function(source) {\n        if (!this._sourcesContents) {\n            return null;\n        }\n        if (aSourceRoot != null) {\n            source = util.relative(aSourceRoot, source);\n        }\n        var key = util.toSetString(source);\n        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;\n    }, this);\n};\n/**\n * Externalize the source map.\n */ SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {\n    var map = {\n        version: this._version,\n        sources: this._sources.toArray(),\n        names: this._names.toArray(),\n        mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n        map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n        map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n    return map;\n};\n/**\n * Render the source map being generated to a string.\n */ SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n};\nexports.SourceMapGenerator = SourceMapGenerator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1qcy9saWIvc291cmNlLW1hcC1nZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUEseUNBQXlDLEdBQ3pDOzs7O0NBSUMsR0FFRCxJQUFJQSxZQUFZQyxtQkFBT0EsQ0FBQztBQUN4QixJQUFJQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUNuQixJQUFJRSxXQUFXRix3R0FBK0I7QUFDOUMsSUFBSUcsY0FBY0gsaUhBQXFDO0FBRXZEOzs7Ozs7O0NBT0MsR0FDRCxTQUFTSSxtQkFBbUJDLEtBQUs7SUFDL0IsSUFBSSxDQUFDQSxPQUFPO1FBQ1ZBLFFBQVEsQ0FBQztJQUNYO0lBQ0EsSUFBSSxDQUFDQyxLQUFLLEdBQUdMLEtBQUtNLE1BQU0sQ0FBQ0YsT0FBTyxRQUFRO0lBQ3hDLElBQUksQ0FBQ0csV0FBVyxHQUFHUCxLQUFLTSxNQUFNLENBQUNGLE9BQU8sY0FBYztJQUNwRCxJQUFJLENBQUNJLGVBQWUsR0FBR1IsS0FBS00sTUFBTSxDQUFDRixPQUFPLGtCQUFrQjtJQUM1RCxJQUFJLENBQUNLLFFBQVEsR0FBRyxJQUFJUjtJQUNwQixJQUFJLENBQUNTLE1BQU0sR0FBRyxJQUFJVDtJQUNsQixJQUFJLENBQUNVLFNBQVMsR0FBRyxJQUFJVDtJQUNyQixJQUFJLENBQUNVLGdCQUFnQixHQUFHO0FBQzFCO0FBRUFULG1CQUFtQlUsU0FBUyxDQUFDQyxRQUFRLEdBQUc7QUFFeEM7Ozs7Q0FJQyxHQUNEWCxtQkFBbUJZLGFBQWEsR0FDOUIsU0FBU0MsaUNBQWlDQyxrQkFBa0I7SUFDMUQsSUFBSUMsYUFBYUQsbUJBQW1CQyxVQUFVO0lBQzlDLElBQUlDLFlBQVksSUFBSWhCLG1CQUFtQjtRQUNyQ2lCLE1BQU1ILG1CQUFtQkcsSUFBSTtRQUM3QkYsWUFBWUE7SUFDZDtJQUNBRCxtQkFBbUJJLFdBQVcsQ0FBQyxTQUFVQyxPQUFPO1FBQzlDLElBQUlDLGFBQWE7WUFDZkMsV0FBVztnQkFDVEMsTUFBTUgsUUFBUUks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LElBQUksQ0FBQ3BGLGdCQUFnQixDQUFDb0YsSUFBSSxHQUMxQjtJQUNOLEdBQUcsSUFBSTtBQUNUO0FBRUY7O0NBRUMsR0FDRDdGLG1CQUFtQlUsU0FBUyxDQUFDc0YsTUFBTSxHQUNqQyxTQUFTQztJQUNQLElBQUlMLE1BQU07UUFDUk0sU0FBUyxJQUFJLENBQUN2RixRQUFRO1FBQ3RCc0IsU0FBUyxJQUFJLENBQUMzQixRQUFRLENBQUM0RSxPQUFPO1FBQzlCaUIsT0FBTyxJQUFJLENBQUM1RixNQUFNLENBQUMyRSxPQUFPO1FBQzFCRCxVQUFVLElBQUksQ0FBQ1osa0JBQWtCO0lBQ25DO0lBQ0EsSUFBSSxJQUFJLENBQUNuRSxLQUFLLElBQUksTUFBTTtRQUN0QjBGLElBQUkzRSxJQUFJLEdBQUcsSUFBSSxDQUFDZixLQUFLO0lBQ3ZCO0lBQ0EsSUFBSSxJQUFJLENBQUNFLFdBQVcsSUFBSSxNQUFNO1FBQzVCd0YsSUFBSTdFLFVBQVUsR0FBRyxJQUFJLENBQUNYLFdBQVc7SUFDbkM7SUFDQSxJQUFJLElBQUksQ0FBQ0ssZ0JBQWdCLEVBQUU7UUFDekJtRixJQUFJUSxjQUFjLEdBQUcsSUFBSSxDQUFDWix1QkFBdUIsQ0FBQ0ksSUFBSTNELE9BQU8sRUFBRTJELElBQUk3RSxVQUFVO0lBQy9FO0lBRUEsT0FBTzZFO0FBQ1Q7QUFFRjs7Q0FFQyxHQUNENUYsbUJBQW1CVSxTQUFTLENBQUMyRixRQUFRLEdBQ25DLFNBQVNDO0lBQ1AsT0FBT25DLEtBQUtDLFNBQVMsQ0FBQyxJQUFJLENBQUM0QixNQUFNO0FBQ25DO0FBRUZPLDBCQUEwQixHQUFHdkciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b3JrZmxvdy8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwLWpzL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcz8yMzNiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG52YXIgTWFwcGluZ0xpc3QgPSByZXF1aXJlKCcuL21hcHBpbmctbGlzdCcpLk1hcHBpbmdMaXN0O1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IgcmVwcmVzZW50cyBhIHNvdXJjZSBtYXAgd2hpY2ggaXNcbiAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gc291cmNlUm9vdDogQSByb290IGZvciBhbGwgcmVsYXRpdmUgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICBpZiAoIWFBcmdzKSB7XG4gICAgYUFyZ3MgPSB7fTtcbiAgfVxuICB0aGlzLl9maWxlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdmaWxlJywgbnVsbCk7XG4gIHRoaXMuX3NvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgJ3NraXBWYWxpZGF0aW9uJywgZmFsc2UpO1xuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX21hcHBpbmdzID0gbmV3IE1hcHBpbmdMaXN0KCk7XG4gIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG59XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgdmFyIHNvdXJjZVJvb3QgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlUm9vdDtcbiAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICBmaWxlOiBhU291cmNlTWFwQ29uc3VtZXIuZmlsZSxcbiAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3RcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIHZhciBuZXdNYXBwaW5nID0ge1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG5ld01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBzb3VyY2VSZWxhdGl2ZSA9IHNvdXJjZUZpbGU7XG4gICAgICBpZiAoc291cmNlUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VSZWxhdGl2ZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZ2VuZXJhdG9yLl9zb3VyY2VzLmhhcyhzb3VyY2VSZWxhdGl2ZSkpIHtcbiAgICAgICAgZ2VuZXJhdG9yLl9zb3VyY2VzLmFkZChzb3VyY2VSZWxhdGl2ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRvci5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH07XG5cbi8qKlxuICogQWRkIGEgc2luZ2xlIG1hcHBpbmcgZnJvbSBvcmlnaW5hbCBzb3VyY2UgbGluZSBhbmQgY29sdW1uIHRvIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKHJlbGF0aXZlIHRvIHRoZSBzb3VyY2VSb290KS5cbiAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgdmFyIGdlbmVyYXRlZCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZ2VuZXJhdGVkJyk7XG4gICAgdmFyIG9yaWdpbmFsID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdvcmlnaW5hbCcsIG51bGwpO1xuICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICduYW1lJywgbnVsbCk7XG5cbiAgICBpZiAoIXRoaXMuX3NraXBWYWxpZGF0aW9uKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZU1hcHBpbmcoZ2VuZXJhdGVkLCBvcmlnaW5hbCwgc291cmNlLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IFN0cmluZyhzb3VyY2UpO1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgIGlmICghdGhpcy5fbmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9tYXBwaW5ncy5hZGQoe1xuICAgICAgZ2VuZXJhdGVkTGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmNvbHVtbixcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgbmFtZTogbmFtZVxuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHZhciBzb3VyY2UgPSBhU291cmNlRmlsZTtcbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKGFTb3VyY2VDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0aGUgc291cmNlIGNvbnRlbnQgdG8gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgc291cmNlIGZpbGUgZnJvbSB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgIGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zb3VyY2VzQ29udGVudHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBtYXBwaW5ncyBvZiBhIHN1Yi1zb3VyY2UtbWFwIGZvciBhIHNwZWNpZmljIHNvdXJjZSBmaWxlIHRvIHRoZVxuICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICogcmVzdWx0aW5nIG1hcHBpbmdzIGlzIHRoZSBtaW5pbWl1bSBvZiB0aGlzIG1hcCBhbmQgdGhlIHN1cHBsaWVkIG1hcC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgT3B0aW9uYWwuIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGUuXG4gKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAqIEBwYXJhbSBhU291cmNlTWFwUGF0aCBPcHRpb25hbC4gVGhlIGRpcm5hbWUgb2YgdGhlIHBhdGggdG8gdGhlIHNvdXJjZSBtYXBcbiAqICAgICAgICB0byBiZSBhcHBsaWVkLiBJZiByZWxhdGl2ZSwgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyLlxuICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gKiAgICAgICAgZGlyZWN0b3J5LCBhbmQgdGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZCBjb250YWlucyByZWxhdGl2ZSBzb3VyY2VcbiAqICAgICAgICBwYXRocy4gSWYgc28sIHRob3NlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBuZWVkIHRvIGJlIHJld3JpdHRlblxuICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICB2YXIgc291cmNlRmlsZSA9IGFTb3VyY2VGaWxlO1xuICAgIC8vIElmIGFTb3VyY2VGaWxlIGlzIG9taXR0ZWQsIHdlIHdpbGwgdXNlIHRoZSBmaWxlIHByb3BlcnR5IG9mIHRoZSBTb3VyY2VNYXBcbiAgICBpZiAoYVNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgaWYgKGFTb3VyY2VNYXBDb25zdW1lci5maWxlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJyArXG4gICAgICAgICAgJ29yIHRoZSBzb3VyY2UgbWFwXFwncyBcImZpbGVcIiBwcm9wZXJ0eS4gQm90aCB3ZXJlIG9taXR0ZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgIH1cbiAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgLy8gTWFrZSBcInNvdXJjZUZpbGVcIiByZWxhdGl2ZSBpZiBhbiBhYnNvbHV0ZSBVcmwgaXMgcGFzc2VkLlxuICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgIH1cbiAgICAvLyBBcHBseWluZyB0aGUgU291cmNlTWFwIGNhbiBhZGQgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2VzIGFuZFxuICAgIC8vIHRoZSBuYW1lcyBhcnJheS5cbiAgICB2YXIgbmV3U291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHZhciBuZXdOYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgLy8gRmluZCBtYXBwaW5ncyBmb3IgdGhlIFwic291cmNlRmlsZVwiXG4gICAgdGhpcy5fbWFwcGluZ3MudW5zb3J0ZWRGb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IHNvdXJjZUZpbGUgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgIT0gbnVsbCkge1xuICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgdmFyIG9yaWdpbmFsID0gYVNvdXJjZU1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgaWYgKG9yaWdpbmFsLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIG5ld1NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiAhbmV3TmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIG5ld05hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cblxuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXdTb3VyY2VzO1xuICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG5cbiAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50cyBvZiBhcHBsaWVkIG1hcC5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogQSBtYXBwaW5nIGNhbiBoYXZlIG9uZSBvZiB0aGUgdGhyZWUgbGV2ZWxzIG9mIGRhdGE6XG4gKlxuICogICAxLiBKdXN0IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKiAgIDIuIFRoZSBHZW5lcmF0ZWQgcG9zaXRpb24sIG9yaWdpbmFsIHBvc2l0aW9uLCBhbmQgb3JpZ2luYWwgc291cmNlLlxuICogICAzLiBHZW5lcmF0ZWQgYW5kIG9yaWdpbmFsIHBvc2l0aW9uLCBvcmlnaW5hbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBuYW1lXG4gKiAgICAgIHRva2VuLlxuICpcbiAqIFRvIG1haW50YWluIGNvbnNpc3RlbmN5LCB3ZSB2YWxpZGF0ZSB0aGF0IGFueSBuZXcgbWFwcGluZyBiZWluZyBhZGRlZCBmYWxsc1xuICogaW4gdG8gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXMuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCwgYU9yaWdpbmFsLCBhU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFOYW1lKSB7XG4gICAgLy8gV2hlbiBhT3JpZ2luYWwgaXMgdHJ1dGh5IGJ1dCBoYXMgZW1wdHkgdmFsdWVzIGZvciAubGluZSBhbmQgLmNvbHVtbixcbiAgICAvLyBpdCBpcyBtb3N0IGxpa2VseSBhIHByb2dyYW1tZXIgZXJyb3IuIEluIHRoaXMgY2FzZSB3ZSB0aHJvdyBhIHZlcnlcbiAgICAvLyBzcGVjaWZpYyBlcnJvciBtZXNzYWdlIHRvIHRyeSB0byBndWlkZSB0aGVtIHRoZSByaWdodCB3YXkuXG4gICAgLy8gRm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXItYnVuZGxlci9wdWxsLzUxOVxuICAgIGlmIChhT3JpZ2luYWwgJiYgdHlwZW9mIGFPcmlnaW5hbC5saW5lICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgYU9yaWdpbmFsLmNvbHVtbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ29yaWdpbmFsLmxpbmUgYW5kIG9yaWdpbmFsLmNvbHVtbiBhcmUgbm90IG51bWJlcnMgLS0geW91IHByb2JhYmx5IG1lYW50IHRvIG9taXQgJyArXG4gICAgICAgICAgICAndGhlIG9yaWdpbmFsIG1hcHBpbmcgZW50aXJlbHkgYW5kIG9ubHkgbWFwIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uIElmIHNvLCBwYXNzICcgK1xuICAgICAgICAgICAgJ251bGwgZm9yIHRoZSBvcmlnaW5hbCBtYXBwaW5nIGluc3RlYWQgb2YgYW4gb2JqZWN0IHdpdGggZW1wdHkgb3IgbnVsbCB2YWx1ZXMuJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICYmICFhT3JpZ2luYWwgJiYgIWFTb3VyY2UgJiYgIWFOYW1lKSB7XG4gICAgICAvLyBDYXNlIDEuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbCAmJiAnbGluZScgaW4gYU9yaWdpbmFsICYmICdjb2x1bW4nIGluIGFPcmlnaW5hbFxuICAgICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhU291cmNlKSB7XG4gICAgICAvLyBDYXNlcyAyIGFuZCAzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXBwaW5nOiAnICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBnZW5lcmF0ZWQ6IGFHZW5lcmF0ZWQsXG4gICAgICAgIHNvdXJjZTogYVNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWw6IGFPcmlnaW5hbCxcbiAgICAgICAgbmFtZTogYU5hbWVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICogc3BlY2lmaWVkIGJ5IHRoZSBzb3VyY2UgbWFwIGZvcm1hdC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2VyaWFsaXplTWFwcGluZ3MoKSB7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRMaW5lID0gMTtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgbmV4dDtcbiAgICB2YXIgbWFwcGluZztcbiAgICB2YXIgbmFtZUlkeDtcbiAgICB2YXIgc291cmNlSWR4O1xuXG4gICAgdmFyIG1hcHBpbmdzID0gdGhpcy5fbWFwcGluZ3MudG9BcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuICAgICAgbmV4dCA9ICcnXG5cbiAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgIHdoaWxlIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG5leHQgKz0gJzsnO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkTGluZSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgaWYgKCF1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmcsIG1hcHBpbmdzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0ICs9ICcsJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlSWR4ID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKHNvdXJjZUlkeCAtIHByZXZpb3VzU291cmNlKTtcbiAgICAgICAgcHJldmlvdXNTb3VyY2UgPSBzb3VyY2VJZHg7XG5cbiAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbExpbmUgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMTtcblxuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuYW1lSWR4ID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShuYW1lSWR4IC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICBwcmV2aW91c05hbWUgPSBuYW1lSWR4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSBuZXh0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZ2VuZXJhdGVTb3VyY2VzQ29udGVudChhU291cmNlcywgYVNvdXJjZVJvb3QpIHtcbiAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGFTb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZShhU291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSk7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cywga2V5KVxuICAgICAgICA/IHRoaXMuX3NvdXJjZXNDb250ZW50c1trZXldXG4gICAgICAgIDogbnVsbDtcbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgIHZhciBtYXAgPSB7XG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICBuYW1lczogdGhpcy5fbmFtZXMudG9BcnJheSgpLFxuICAgICAgbWFwcGluZ3M6IHRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKClcbiAgICB9O1xuICAgIGlmICh0aGlzLl9maWxlICE9IG51bGwpIHtcbiAgICAgIG1hcC5maWxlID0gdGhpcy5fZmlsZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbWFwLnNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSB0aGlzLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KG1hcC5zb3VyY2VzLCBtYXAuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKTtcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG4iXSwibmFtZXMiOlsiYmFzZTY0VkxRIiwicmVxdWlyZSIsInV0aWwiLCJBcnJheVNldCIsIk1hcHBpbmdMaXN0IiwiU291cmNlTWFwR2VuZXJhdG9yIiwiYUFyZ3MiLCJfZmlsZSIsImdldEFyZyIsIl9zb3VyY2VSb290IiwiX3NraXBWYWxpZGF0aW9uIiwiX3NvdXJjZXMiLCJfbmFtZXMiLCJfbWFwcGluZ3MiLCJfc291cmNlc0NvbnRlbnRzIiwicHJvdG90eXBlIiwiX3ZlcnNpb24iLCJmcm9tU291cmNlTWFwIiwiU291cmNlTWFwR2VuZXJhdG9yX2Zyb21Tb3VyY2VNYXAiLCJhU291cmNlTWFwQ29uc3VtZXIiLCJzb3VyY2VSb290IiwiZ2VuZXJhdG9yIiwiZmlsZSIsImVhY2hNYXBwaW5nIiwibWFwcGluZyIsIm5ld01hcHBpbmciLCJnZW5lcmF0ZWQiLCJsaW5lIiwiZ2VuZXJhdGVkTGluZSIsImNvbHVtbiIsImdlbmVyYXRlZENvbHVtbiIsInNvdXJjZSIsInJlbGF0aXZlIiwib3JpZ2luYWwiLCJvcmlnaW5hbExpbmUiLCJvcmlnaW5hbENvbHVtbiIsIm5hbWUiLCJhZGRNYXBwaW5nIiwic291cmNlcyIsImZvckVhY2giLCJzb3VyY2VGaWxlIiwic291cmNlUmVsYXRpdmUiLCJoYXMiLCJhZGQiLCJjb250ZW50Iiwic291cmNlQ29udGVudEZvciIsInNldFNvdXJjZUNvbnRlbnQiLCJTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyIsIl92YWxpZGF0ZU1hcHBpbmciLCJTdHJpbmciLCJTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudCIsImFTb3VyY2VGaWxlIiwiYVNvdXJjZUNvbnRlbnQiLCJPYmplY3QiLCJjcmVhdGUiLCJ0b1NldFN0cmluZyIsImtleXMiLCJsZW5ndGgiLCJhcHBseVNvdXJjZU1hcCIsIlNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcCIsImFTb3VyY2VNYXBQYXRoIiwiRXJyb3IiLCJuZXdTb3VyY2VzIiwibmV3TmFtZXMiLCJ1bnNvcnRlZEZvckVhY2giLCJvcmlnaW5hbFBvc2l0aW9uRm9yIiwiam9pbiIsIlNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmciLCJhR2VuZXJhdGVkIiwiYU9yaWdpbmFsIiwiYVNvdXJjZSIsImFOYW1lIiwiSlNPTiIsInN0cmluZ2lmeSIsIl9zZXJpYWxpemVNYXBwaW5ncyIsIlNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncyIsInByZXZpb3VzR2VuZXJhdGVkQ29sdW1uIiwicHJldmlvdXNHZW5lcmF0ZWRMaW5lIiwicHJldmlvdXNPcmlnaW5hbENvbHVtbiIsInByZXZpb3VzT3JpZ2luYWxMaW5lIiwicHJldmlvdXNOYW1lIiwicHJldmlvdXNTb3VyY2UiLCJyZXN1bHQiLCJuZXh0IiwibmFtZUlkeCIsInNvdXJjZUlkeCIsIm1hcHBpbmdzIiwidG9BcnJheSIsImkiLCJsZW4iLCJjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCIsImVuY29kZSIsImluZGV4T2YiLCJfZ2VuZXJhdGVTb3VyY2VzQ29udGVudCIsIlNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50IiwiYVNvdXJjZXMiLCJhU291cmNlUm9vdCIsIm1hcCIsImtleSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInRvSlNPTiIsIlNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04iLCJ2ZXJzaW9uIiwibmFtZXMiLCJzb3VyY2VzQ29udGVudCIsInRvU3RyaW5nIiwiU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/source-map-js/lib/source-map-generator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/source-map-js/lib/source-node.js":
/*!*******************************************************!*\
  !*** ./node_modules/source-map-js/lib/source-node.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var SourceMapGenerator = (__webpack_require__(/*! ./source-map-generator */ \"(ssr)/./node_modules/source-map-js/lib/source-map-generator.js\").SourceMapGenerator);\nvar util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/source-map-js/lib/util.js\");\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */ function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine == null ? null : aLine;\n    this.column = aColumn == null ? null : aColumn;\n    this.source = aSource == null ? null : aSource;\n    this.name = aName == null ? null : aName;\n    this[isSourceNode] = true;\n    if (aChunks != null) this.add(aChunks);\n}\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */ SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n        var lineContents = getNextLine();\n        // The last line of a file might not have a newline.\n        var newLine = getNextLine() || \"\";\n        return lineContents + newLine;\n        function getNextLine() {\n            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;\n        }\n    };\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n    aSourceMapConsumer.eachMapping(function(mapping) {\n        if (lastMapping !== null) {\n            // We add the code from \"lastMapping\" to \"mapping\":\n            // First check if there is a new line in between.\n            if (lastGeneratedLine < mapping.generatedLine) {\n                // Associate first line with \"lastMapping\"\n                addMappingWithCode(lastMapping, shiftNextLine());\n                lastGeneratedLine++;\n                lastGeneratedColumn = 0;\n            // The remaining code is added without mapping\n            } else {\n                // There is no new line in between.\n                // Associate the code between \"lastGeneratedColumn\" and\n                // \"mapping.generatedColumn\" with \"lastMapping\"\n                var nextLine = remainingLines[remainingLinesIndex] || \"\";\n                var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n                remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n                lastGeneratedColumn = mapping.generatedColumn;\n                addMappingWithCode(lastMapping, code);\n                // No more remaining code, continue\n                lastMapping = mapping;\n                return;\n            }\n        }\n        // We add the generated code until the first mapping\n        // to the SourceNode without any mapping.\n        // Each line is added as separate string.\n        while(lastGeneratedLine < mapping.generatedLine){\n            node.add(shiftNextLine());\n            lastGeneratedLine++;\n        }\n        if (lastGeneratedColumn < mapping.generatedColumn) {\n            var nextLine = remainingLines[remainingLinesIndex] || \"\";\n            node.add(nextLine.substr(0, mapping.generatedColumn));\n            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n            lastGeneratedColumn = mapping.generatedColumn;\n        }\n        lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n        if (lastMapping) {\n            // Associate the remaining code in the current line with \"lastMapping\"\n            addMappingWithCode(lastMapping, shiftNextLine());\n        }\n        // and add the remaining lines without any mapping\n        node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n            if (aRelativePath != null) {\n                sourceFile = util.join(aRelativePath, sourceFile);\n            }\n            node.setSourceContent(sourceFile, content);\n        }\n    });\n    return node;\n    function addMappingWithCode(mapping, code) {\n        if (mapping === null || mapping.source === undefined) {\n            node.add(code);\n        } else {\n            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n            node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n        }\n    }\n};\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */ SourceNode.prototype.add = function SourceNode_add(aChunk) {\n    if (Array.isArray(aChunk)) {\n        aChunk.forEach(function(chunk) {\n            this.add(chunk);\n        }, this);\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n        if (aChunk) {\n            this.children.push(aChunk);\n        }\n    } else {\n        throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n    }\n    return this;\n};\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */ SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n    if (Array.isArray(aChunk)) {\n        for(var i = aChunk.length - 1; i >= 0; i--){\n            this.prepend(aChunk[i]);\n        }\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n        this.children.unshift(aChunk);\n    } else {\n        throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n    }\n    return this;\n};\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */ SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n    var chunk;\n    for(var i = 0, len = this.children.length; i < len; i++){\n        chunk = this.children[i];\n        if (chunk[isSourceNode]) {\n            chunk.walk(aFn);\n        } else {\n            if (chunk !== \"\") {\n                aFn(chunk, {\n                    source: this.source,\n                    line: this.line,\n                    column: this.column,\n                    name: this.name\n                });\n            }\n        }\n    }\n};\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */ SourceNode.prototype.join = function SourceNode_join(aSep) {\n    var newChildren;\n    var i;\n    var len = this.children.length;\n    if (len > 0) {\n        newChildren = [];\n        for(i = 0; i < len - 1; i++){\n            newChildren.push(this.children[i]);\n            newChildren.push(aSep);\n        }\n        newChildren.push(this.children[i]);\n        this.children = newChildren;\n    }\n    return this;\n};\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */ SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n    var lastChild = this.children[this.children.length - 1];\n    if (lastChild[isSourceNode]) {\n        lastChild.replaceRight(aPattern, aReplacement);\n    } else if (typeof lastChild === \"string\") {\n        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n    } else {\n        this.children.push(\"\".replace(aPattern, aReplacement));\n    }\n    return this;\n};\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */ SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n};\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */ SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n    for(var i = 0, len = this.children.length; i < len; i++){\n        if (this.children[i][isSourceNode]) {\n            this.children[i].walkSourceContents(aFn);\n        }\n    }\n    var sources = Object.keys(this.sourceContents);\n    for(var i = 0, len = sources.length; i < len; i++){\n        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n};\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */ SourceNode.prototype.toString = function SourceNode_toString() {\n    var str = \"\";\n    this.walk(function(chunk) {\n        str += chunk;\n    });\n    return str;\n};\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */ SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n    var generated = {\n        code: \"\",\n        line: 1,\n        column: 0\n    };\n    var map = new SourceMapGenerator(aArgs);\n    var sourceMappingActive = false;\n    var lastOriginalSource = null;\n    var lastOriginalLine = null;\n    var lastOriginalColumn = null;\n    var lastOriginalName = null;\n    this.walk(function(chunk, original) {\n        generated.code += chunk;\n        if (original.source !== null && original.line !== null && original.column !== null) {\n            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n                map.addMapping({\n                    source: original.source,\n                    original: {\n                        line: original.line,\n                        column: original.column\n                    },\n                    generated: {\n                        line: generated.line,\n                        column: generated.column\n                    },\n                    name: original.name\n                });\n            }\n            lastOriginalSource = original.source;\n            lastOriginalLine = original.line;\n            lastOriginalColumn = original.column;\n            lastOriginalName = original.name;\n            sourceMappingActive = true;\n        } else if (sourceMappingActive) {\n            map.addMapping({\n                generated: {\n                    line: generated.line,\n                    column: generated.column\n                }\n            });\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n        }\n        for(var idx = 0, length = chunk.length; idx < length; idx++){\n            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n                generated.line++;\n                generated.column = 0;\n                // Mappings end at eol\n                if (idx + 1 === length) {\n                    lastOriginalSource = null;\n                    sourceMappingActive = false;\n                } else if (sourceMappingActive) {\n                    map.addMapping({\n                        source: original.source,\n                        original: {\n                            line: original.line,\n                            column: original.column\n                        },\n                        generated: {\n                            line: generated.line,\n                            column: generated.column\n                        },\n                        name: original.name\n                    });\n                }\n            } else {\n                generated.column++;\n            }\n        }\n    });\n    this.walkSourceContents(function(sourceFile, sourceContent) {\n        map.setSourceContent(sourceFile, sourceContent);\n    });\n    return {\n        code: generated.code,\n        map: map\n    };\n};\nexports.SourceNode = SourceNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1qcy9saWIvc291cmNlLW5vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUEseUNBQXlDLEdBQ3pDOzs7O0NBSUMsR0FFRCxJQUFJQSxxQkFBcUJDLHdJQUFvRDtBQUM3RSxJQUFJQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUVuQiw2RUFBNkU7QUFDN0UsdURBQXVEO0FBQ3ZELElBQUlFLGdCQUFnQjtBQUVwQixzREFBc0Q7QUFDdEQsSUFBSUMsZUFBZTtBQUVuQix5RUFBeUU7QUFDekUsaUVBQWlFO0FBQ2pFLFlBQVk7QUFDWixJQUFJQyxlQUFlO0FBRW5COzs7Ozs7Ozs7OztDQVdDLEdBQ0QsU0FBU0MsV0FBV0MsS0FBSyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxLQUFLO0lBQ3pELElBQUksQ0FBQ0MsUUFBUSxHQUFHLEVBQUU7SUFDbEIsSUFBSSxDQUFDQyxjQUFjLEdBQUcsQ0FBQztJQUN2QixJQUFJLENBQUNDLElBQUksR0FBR1AsU0FBUyxPQUFPLE9BQU9BO0lBQ25DLElBQUksQ0FBQ1EsTUFBTSxHQUFHUCxXQUFXLE9BQU8sT0FBT0E7SUFDdkMsSUFBSSxDQUFDUSxNQUFNLEdBQUdQLFdBQVcsT0FBTyxPQUFPQTtJQUN2QyxJQUFJLENBQUNRLElBQUksR0FBR04sU0FBUyxPQUFPLE9BQU9BO0lBQ25DLElBQUksQ0FBQ04sYUFBYSxHQUFHO0lBQ3JCLElBQUlLLFdBQVcsTUFBTSxJQUFJLENBQUNRLEdBQUcsQ0FBQ1I7QUFDaEM7QUFFQTs7Ozs7OztDQU9DLEdBQ0RKLFdBQVdhLHVCQUF1QixHQUNoQyxTQUFTQyxtQ0FBbUNDLGNBQWMsRUFBRUMsa0JBQWtCLEVBQUVDLGFBQWE7SUFDM0YseURBQXlEO0lBQ3pELG9CQUFvQjtJQUNwQixJQUFJQyxPQUFPLElBQUlsQjtJQUVmLHFFQUFxRTtJQUNyRSxvRUFBb0U7SUFDcEUsOENBQThDO0lBQzlDLCtEQUErRDtJQUMvRCxJQUFJbUIs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RixJQUFJOzRCQUNwQkMsUUFBUWdGLFVBQVVoRixNQUFNO3dCQUMxQjt3QkFDQUUsTUFBTXFGLFNBQVNyRixJQUFJO29CQUNyQjtnQkFDRjtZQUNGLE9BQU87Z0JBQ0w4RSxVQUFVaEYsTUFBTTtZQUNsQjtRQUNGO0lBQ0Y7SUFDQSxJQUFJLENBQUNxRSxrQkFBa0IsQ0FBQyxTQUFVbkMsVUFBVSxFQUFFeUQsYUFBYTtRQUN6RFYsSUFBSTVDLGdCQUFnQixDQUFDSCxZQUFZeUQ7SUFDbkM7SUFFQSxPQUFPO1FBQUVoRSxNQUFNcUQsVUFBVXJELElBQUk7UUFBRXNELEtBQUtBO0lBQUk7QUFDMUM7QUFFQVcsa0JBQWtCLEdBQUdyRyIsInNvdXJjZXMiOlsid2VicGFjazovL3dvcmtmbG93Ly4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtanMvbGliL3NvdXJjZS1ub2RlLmpzPzVlNmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIE1hdGNoZXMgYSBXaW5kb3dzLXN0eWxlIGBcXHJcXG5gIG5ld2xpbmUgb3IgYSBgXFxuYCBuZXdsaW5lIHVzZWQgYnkgYWxsIG90aGVyXG4vLyBvcGVyYXRpbmcgc3lzdGVtcyB0aGVzZSBkYXlzIChjYXB0dXJpbmcgdGhlIHJlc3VsdCkuXG52YXIgUkVHRVhfTkVXTElORSA9IC8oXFxyP1xcbikvO1xuXG4vLyBOZXdsaW5lIGNoYXJhY3RlciBjb2RlIGZvciBjaGFyQ29kZUF0KCkgY29tcGFyaXNvbnNcbnZhciBORVdMSU5FX0NPREUgPSAxMDtcblxuLy8gUHJpdmF0ZSBzeW1ib2wgZm9yIGlkZW50aWZ5aW5nIGBTb3VyY2VOb2RlYHMgd2hlbiBtdWx0aXBsZSB2ZXJzaW9ucyBvZlxuLy8gdGhlIHNvdXJjZS1tYXAgbGlicmFyeSBhcmUgbG9hZGVkLiBUaGlzIE1VU1QgTk9UIENIQU5HRSBhY3Jvc3Ncbi8vIHZlcnNpb25zIVxudmFyIGlzU291cmNlTm9kZSA9IFwiJCQkaXNTb3VyY2VOb2RlJCQkXCI7XG5cbi8qKlxuICogU291cmNlTm9kZXMgcHJvdmlkZSBhIHdheSB0byBhYnN0cmFjdCBvdmVyIGludGVycG9sYXRpbmcvY29uY2F0ZW5hdGluZ1xuICogc25pcHBldHMgb2YgZ2VuZXJhdGVkIEphdmFTY3JpcHQgc291cmNlIGNvZGUgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIGxpbmUgYW5kXG4gKiBjb2x1bW4gaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcGFyYW0gYUxpbmUgVGhlIG9yaWdpbmFsIGxpbmUgbnVtYmVyLlxuICogQHBhcmFtIGFDb2x1bW4gVGhlIG9yaWdpbmFsIGNvbHVtbiBudW1iZXIuXG4gKiBAcGFyYW0gYVNvdXJjZSBUaGUgb3JpZ2luYWwgc291cmNlJ3MgZmlsZW5hbWUuXG4gKiBAcGFyYW0gYUNodW5rcyBPcHRpb25hbC4gQW4gYXJyYXkgb2Ygc3RyaW5ncyB3aGljaCBhcmUgc25pcHBldHMgb2ZcbiAqICAgICAgICBnZW5lcmF0ZWQgSlMsIG9yIG90aGVyIFNvdXJjZU5vZGVzLlxuICogQHBhcmFtIGFOYW1lIFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLlxuICovXG5mdW5jdGlvbiBTb3VyY2VOb2RlKGFMaW5lLCBhQ29sdW1uLCBhU291cmNlLCBhQ2h1bmtzLCBhTmFtZSkge1xuICB0aGlzLmNoaWxkcmVuID0gW107XG4gIHRoaXMuc291cmNlQ29udGVudHMgPSB7fTtcbiAgdGhpcy5saW5lID0gYUxpbmUgPT0gbnVsbCA/IG51bGwgOiBhTGluZTtcbiAgdGhpcy5jb2x1bW4gPSBhQ29sdW1uID09IG51bGwgPyBudWxsIDogYUNvbHVtbjtcbiAgdGhpcy5zb3VyY2UgPSBhU291cmNlID09IG51bGwgPyBudWxsIDogYVNvdXJjZTtcbiAgdGhpcy5uYW1lID0gYU5hbWUgPT0gbnVsbCA/IG51bGwgOiBhTmFtZTtcbiAgdGhpc1tpc1NvdXJjZU5vZGVdID0gdHJ1ZTtcbiAgaWYgKGFDaHVua3MgIT0gbnVsbCkgdGhpcy5hZGQoYUNodW5rcyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNvdXJjZU5vZGUgZnJvbSBnZW5lcmF0ZWQgY29kZSBhbmQgYSBTb3VyY2VNYXBDb25zdW1lci5cbiAqXG4gKiBAcGFyYW0gYUdlbmVyYXRlZENvZGUgVGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAgZm9yIHRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFSZWxhdGl2ZVBhdGggT3B0aW9uYWwuIFRoZSBwYXRoIHRoYXQgcmVsYXRpdmUgc291cmNlcyBpbiB0aGVcbiAqICAgICAgICBTb3VyY2VNYXBDb25zdW1lciBzaG91bGQgYmUgcmVsYXRpdmUgdG8uXG4gKi9cblNvdXJjZU5vZGUuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX2Zyb21TdHJpbmdXaXRoU291cmNlTWFwKGFHZW5lcmF0ZWRDb2RlLCBhU291cmNlTWFwQ29uc3VtZXIsIGFSZWxhdGl2ZVBhdGgpIHtcbiAgICAvLyBUaGUgU291cmNlTm9kZSB3ZSB3YW50IHRvIGZpbGwgd2l0aCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAvLyBhbmQgdGhlIFNvdXJjZU1hcFxuICAgIHZhciBub2RlID0gbmV3IFNvdXJjZU5vZGUoKTtcblxuICAgIC8vIEFsbCBldmVuIGluZGljZXMgb2YgdGhpcyBhcnJheSBhcmUgb25lIGxpbmUgb2YgdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAgIC8vIHdoaWxlIGFsbCBvZGQgaW5kaWNlcyBhcmUgdGhlIG5ld2xpbmVzIGJldHdlZW4gdHdvIGFkamFjZW50IGxpbmVzXG4gICAgLy8gKHNpbmNlIGBSRUdFWF9ORVdMSU5FYCBjYXB0dXJlcyBpdHMgbWF0Y2gpLlxuICAgIC8vIFByb2Nlc3NlZCBmcmFnbWVudHMgYXJlIGFjY2Vzc2VkIGJ5IGNhbGxpbmcgYHNoaWZ0TmV4dExpbmVgLlxuICAgIHZhciByZW1haW5pbmdMaW5lcyA9IGFHZW5lcmF0ZWRDb2RlLnNwbGl0KFJFR0VYX05FV0xJTkUpO1xuICAgIHZhciByZW1haW5pbmdMaW5lc0luZGV4ID0gMDtcbiAgICB2YXIgc2hpZnROZXh0TGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVDb250ZW50cyA9IGdldE5leHRMaW5lKCk7XG4gICAgICAvLyBUaGUgbGFzdCBsaW5lIG9mIGEgZmlsZSBtaWdodCBub3QgaGF2ZSBhIG5ld2xpbmUuXG4gICAgICB2YXIgbmV3TGluZSA9IGdldE5leHRMaW5lKCkgfHwgXCJcIjtcbiAgICAgIHJldHVybiBsaW5lQ29udGVudHMgKyBuZXdMaW5lO1xuXG4gICAgICBmdW5jdGlvbiBnZXROZXh0TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZ0xpbmVzSW5kZXggPCByZW1haW5pbmdMaW5lcy5sZW5ndGggP1xuICAgICAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleCsrXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gV2UgbmVlZCB0byByZW1lbWJlciB0aGUgcG9zaXRpb24gb2YgXCJyZW1haW5pbmdMaW5lc1wiXG4gICAgdmFyIGxhc3RHZW5lcmF0ZWRMaW5lID0gMSwgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgLy8gVG8gZXh0cmFjdCBpdCBjdXJyZW50IGFuZCBsYXN0IG1hcHBpbmcgaXMgdXNlZC5cbiAgICAvLyBIZXJlIHdlIHN0b3JlIHRoZSBsYXN0IG1hcHBpbmcuXG4gICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICBpZiAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAvLyBBc3NvY2lhdGUgZmlyc3QgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgY29kZSBpcyBhZGRlZCB3aXRob3V0IG1hcHBpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuICAgICAgICAgIC8vIFwibWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cIiB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdIHx8ICcnO1xuICAgICAgICAgIHZhciBjb2RlID0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgLy8gTm8gbW9yZSByZW1haW5pbmcgY29kZSwgY29udGludWVcbiAgICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSBhZGQgdGhlIGdlbmVyYXRlZCBjb2RlIHVudGlsIHRoZSBmaXJzdCBtYXBwaW5nXG4gICAgICAvLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuICAgICAgLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgIHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICBub2RlLmFkZChzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRDb2x1bW4gPCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikge1xuICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSB8fCAnJztcbiAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgfVxuICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgIH0sIHRoaXMpO1xuICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICBpZiAocmVtYWluaW5nTGluZXNJbmRleCA8IHJlbWFpbmluZ0xpbmVzLmxlbmd0aCkge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nKSB7XG4gICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICB9XG4gICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgbm9kZS5hZGQocmVtYWluaW5nTGluZXMuc3BsaWNlKHJlbWFpbmluZ0xpbmVzSW5kZXgpLmpvaW4oXCJcIikpO1xuICAgIH1cblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnQgaW50byBTb3VyY2VOb2RlXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFSZWxhdGl2ZVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGU7XG5cbiAgICBmdW5jdGlvbiBhZGRNYXBwaW5nV2l0aENvZGUobWFwcGluZywgY29kZSkge1xuICAgICAgaWYgKG1hcHBpbmcgPT09IG51bGwgfHwgbWFwcGluZy5zb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLmFkZChjb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhUmVsYXRpdmVQYXRoXG4gICAgICAgICAgPyB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgOiBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgbm9kZS5hZGQobmV3IFNvdXJjZU5vZGUobWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5uYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfYWRkKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgYUNodW5rLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICB0aGlzLmFkZChjaHVuayk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChhQ2h1bmspIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChhQ2h1bmspO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgIGZvciAodmFyIGkgPSBhQ2h1bmsubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRoaXMuY2hpbGRyZW4udW5zaGlmdChhQ2h1bmspO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIEpTIHNuaXBwZXRzIGluIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBUaGVcbiAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAqIHNuaXBwZXQgYW5kIHRoZSBpdHMgb3JpZ2luYWwgYXNzb2NpYXRlZCBzb3VyY2UncyBsaW5lL2NvbHVtbiBsb2NhdGlvbi5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGsoYUZuKSB7XG4gIHZhciBjaHVuaztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjaHVuayA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgaWYgKGNodW5rW2lzU291cmNlTm9kZV0pIHtcbiAgICAgIGNodW5rLndhbGsoYUZuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY2h1bmsgIT09ICcnKSB7XG4gICAgICAgIGFGbihjaHVuaywgeyBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTGlrZSBgU3RyaW5nLnByb3RvdHlwZS5qb2luYCBleGNlcHQgZm9yIFNvdXJjZU5vZGVzLiBJbnNlcnRzIGBhU3RyYCBiZXR3ZWVuXG4gKiBlYWNoIG9mIGB0aGlzLmNoaWxkcmVuYC5cbiAqXG4gKiBAcGFyYW0gYVNlcCBUaGUgc2VwYXJhdG9yLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gU291cmNlTm9kZV9qb2luKGFTZXApIHtcbiAgdmFyIG5ld0NoaWxkcmVuO1xuICB2YXIgaTtcbiAgdmFyIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICBpZiAobGVuID4gMCkge1xuICAgIG5ld0NoaWxkcmVuID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbi0xOyBpKyspIHtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKGFTZXApO1xuICAgIH1cbiAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Ugb24gdGhlIHZlcnkgcmlnaHQtbW9zdCBzb3VyY2Ugc25pcHBldC4gVXNlZnVsXG4gKiBmb3IgdHJpbW1pbmcgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmQgb2YgYSBzb3VyY2Ugbm9kZSwgZXRjLlxuICpcbiAqIEBwYXJhbSBhUGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICogQHBhcmFtIGFSZXBsYWNlbWVudCBUaGUgdGhpbmcgdG8gcmVwbGFjZSB0aGUgcGF0dGVybiB3aXRoLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3JlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KSB7XG4gIHZhciBsYXN0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gIGlmIChsYXN0Q2hpbGRbaXNTb3VyY2VOb2RlXSkge1xuICAgIGxhc3RDaGlsZC5yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGxhc3RDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBsYXN0Q2hpbGQucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goJycucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yXG4gKiBpbiB0aGUgc291cmNlc0NvbnRlbnQgZmllbGQuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcbiAqIEBwYXJhbSBhU291cmNlQ29udGVudCBUaGUgY29udGVudCBvZiB0aGUgc291cmNlIGZpbGVcbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICB9O1xuXG4vKipcbiAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gKiBzb3VyY2UgZmlsZSBjb250ZW50IGFuZCBpcyBwYXNzZWQgdGhlIGZpbGVuYW1lIGFuZCBzb3VyY2UgY29udGVudC5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGtTb3VyY2VDb250ZW50cyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbltpXVtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYUZuKHV0aWwuZnJvbVNldFN0cmluZyhzb3VyY2VzW2ldKSwgdGhpcy5zb3VyY2VDb250ZW50c1tzb3VyY2VzW2ldXSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUuIFdhbGtzIG92ZXIgdGhlIHRyZWVcbiAqIGFuZCBjb25jYXRlbmF0ZXMgYWxsIHRoZSB2YXJpb3VzIHNuaXBwZXRzIHRvZ2V0aGVyIHRvIG9uZSBzdHJpbmcuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpIHtcbiAgdmFyIHN0ciA9IFwiXCI7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBzdHIgKz0gY2h1bms7XG4gIH0pO1xuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZSBhbG9uZyB3aXRoIGEgc291cmNlXG4gKiBtYXAuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwKGFBcmdzKSB7XG4gIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgY29kZTogXCJcIixcbiAgICBsaW5lOiAxLFxuICAgIGNvbHVtbjogMFxuICB9O1xuICB2YXIgbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncyk7XG4gIHZhciBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gIHZhciBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTmFtZSA9IG51bGw7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmssIG9yaWdpbmFsKSB7XG4gICAgZ2VuZXJhdGVkLmNvZGUgKz0gY2h1bms7XG4gICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPT0gbnVsbFxuICAgICAgICAmJiBvcmlnaW5hbC5saW5lICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmNvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgaWYobGFzdE9yaWdpbmFsU291cmNlICE9PSBvcmlnaW5hbC5zb3VyY2VcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbExpbmUgIT09IG9yaWdpbmFsLmxpbmVcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbENvbHVtbiAhPT0gb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxOYW1lICE9PSBvcmlnaW5hbC5uYW1lKSB7XG4gICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgbGFzdE9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICBsYXN0T3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSBjaHVuay5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGlmIChjaHVuay5jaGFyQ29kZUF0KGlkeCkgPT09IE5FV0xJTkVfQ09ERSkge1xuICAgICAgICBnZW5lcmF0ZWQubGluZSsrO1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgLy8gTWFwcGluZ3MgZW5kIGF0IGVvbFxuICAgICAgICBpZiAoaWR4ICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbisrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uIChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KSB7XG4gICAgbWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgc291cmNlQ29udGVudCk7XG4gIH0pO1xuXG4gIHJldHVybiB7IGNvZGU6IGdlbmVyYXRlZC5jb2RlLCBtYXA6IG1hcCB9O1xufTtcblxuZXhwb3J0cy5Tb3VyY2VOb2RlID0gU291cmNlTm9kZTtcbiJdLCJuYW1lcyI6WyJTb3VyY2VNYXBHZW5lcmF0b3IiLCJyZXF1aXJlIiwidXRpbCIsIlJFR0VYX05FV0xJTkUiLCJORVdMSU5FX0NPREUiLCJpc1NvdXJjZU5vZGUiLCJTb3VyY2VOb2RlIiwiYUxpbmUiLCJhQ29sdW1uIiwiYVNvdXJjZSIsImFDaHVua3MiLCJhTmFtZSIsImNoaWxkcmVuIiwic291cmNlQ29udGVudHMiLCJsaW5lIiwiY29sdW1uIiwic291cmNlIiwibmFtZSIsImFkZCIsImZyb21TdHJpbmdXaXRoU291cmNlTWFwIiwiU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCIsImFHZW5lcmF0ZWRDb2RlIiwiYVNvdXJjZU1hcENvbnN1bWVyIiwiYVJlbGF0aXZlUGF0aCIsIm5vZGUiLCJyZW1haW5pbmdMaW5lcyIsInNwbGl0IiwicmVtYWluaW5nTGluZXNJbmRleCIsInNoaWZ0TmV4dExpbmUiLCJsaW5lQ29udGVudHMiLCJnZXROZXh0TGluZSIsIm5ld0xpbmUiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJsYXN0R2VuZXJhdGVkTGluZSIsImxhc3RHZW5lcmF0ZWRDb2x1bW4iLCJsYXN0TWFwcGluZyIsImVhY2hNYXBwaW5nIiwibWFwcGluZyIsImdlbmVyYXRlZExpbmUiLCJhZGRNYXBwaW5nV2l0aENvZGUiLCJuZXh0TGluZSIsImNvZGUiLCJzdWJzdHIiLCJnZW5lcmF0ZWRDb2x1bW4iLCJzcGxpY2UiLCJqb2luIiwic291cmNlcyIsImZvckVhY2giLCJzb3VyY2VGaWxlIiwiY29udGVudCIsInNvdXJjZUNvbnRlbnRGb3IiLCJzZXRTb3VyY2VDb250ZW50Iiwib3JpZ2luYWxMaW5lIiwib3JpZ2luYWxDb2x1bW4iLCJwcm90b3R5cGUiLCJTb3VyY2VOb2RlX2FkZCIsImFDaHVuayIsIkFycmF5IiwiaXNBcnJheSIsImNodW5rIiwicHVzaCIsIlR5cGVFcnJvciIsInByZXBlbmQiLCJTb3VyY2VOb2RlX3ByZXBlbmQiLCJpIiwidW5zaGlmdCIsIndhbGsiLCJTb3VyY2VOb2RlX3dhbGsiLCJhRm4iLCJsZW4iLCJTb3VyY2VOb2RlX2pvaW4iLCJhU2VwIiwibmV3Q2hpbGRyZW4iLCJyZXBsYWNlUmlnaHQiLCJTb3VyY2VOb2RlX3JlcGxhY2VSaWdodCIsImFQYXR0ZXJuIiwiYVJlcGxhY2VtZW50IiwibGFzdENoaWxkIiwicmVwbGFjZSIsIlNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudCIsImFTb3VyY2VGaWxlIiwiYVNvdXJjZUNvbnRlbnQiLCJ0b1NldFN0cmluZyIsIndhbGtTb3VyY2VDb250ZW50cyIsIlNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzIiwiT2JqZWN0Iiwia2V5cyIsImZyb21TZXRTdHJpbmciLCJ0b1N0cmluZyIsIlNvdXJjZU5vZGVfdG9TdHJpbmciLCJzdHIiLCJ0b1N0cmluZ1dpdGhTb3VyY2VNYXAiLCJTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcCIsImFBcmdzIiwiZ2VuZXJhdGVkIiwibWFwIiwic291cmNlTWFwcGluZ0FjdGl2ZSIsImxhc3RPcmlnaW5hbFNvdXJjZSIsImxhc3RPcmlnaW5hbExpbmUiLCJsYXN0T3JpZ2luYWxDb2x1bW4iLCJsYXN0T3JpZ2luYWxOYW1lIiwib3JpZ2luYWwiLCJhZGRNYXBwaW5nIiwiaWR4IiwiY2hhckNvZGVBdCIsInNvdXJjZUNvbnRlbnQiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/source-map-js/lib/source-node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/source-map-js/lib/util.js":
/*!************************************************!*\
  !*** ./node_modules/source-map-js/lib/util.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ /**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */ function getArg(aArgs, aName, aDefaultValue) {\n    if (aName in aArgs) {\n        return aArgs[aName];\n    } else if (arguments.length === 3) {\n        return aDefaultValue;\n    } else {\n        throw new Error('\"' + aName + '\" is a required argument.');\n    }\n}\nexports.getArg = getArg;\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\nfunction urlParse(aUrl) {\n    var match = aUrl.match(urlRegexp);\n    if (!match) {\n        return null;\n    }\n    return {\n        scheme: match[1],\n        auth: match[2],\n        host: match[3],\n        port: match[4],\n        path: match[5]\n    };\n}\nexports.urlParse = urlParse;\nfunction urlGenerate(aParsedUrl) {\n    var url = \"\";\n    if (aParsedUrl.scheme) {\n        url += aParsedUrl.scheme + \":\";\n    }\n    url += \"//\";\n    if (aParsedUrl.auth) {\n        url += aParsedUrl.auth + \"@\";\n    }\n    if (aParsedUrl.host) {\n        url += aParsedUrl.host;\n    }\n    if (aParsedUrl.port) {\n        url += \":\" + aParsedUrl.port;\n    }\n    if (aParsedUrl.path) {\n        url += aParsedUrl.path;\n    }\n    return url;\n}\nexports.urlGenerate = urlGenerate;\nvar MAX_CACHED_INPUTS = 32;\n/**\n * Takes some function `f(input) -> result` and returns a memoized version of\n * `f`.\n *\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\n * memoization is a dumb-simple, linear least-recently-used cache.\n */ function lruMemoize(f) {\n    var cache = [];\n    return function(input) {\n        for(var i = 0; i < cache.length; i++){\n            if (cache[i].input === input) {\n                var temp = cache[0];\n                cache[0] = cache[i];\n                cache[i] = temp;\n                return cache[0].result;\n            }\n        }\n        var result = f(input);\n        cache.unshift({\n            input,\n            result\n        });\n        if (cache.length > MAX_CACHED_INPUTS) {\n            cache.pop();\n        }\n        return result;\n    };\n}\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */ var normalize = lruMemoize(function normalize(aPath) {\n    var path = aPath;\n    var url = urlParse(aPath);\n    if (url) {\n        if (!url.path) {\n            return aPath;\n        }\n        path = url.path;\n    }\n    var isAbsolute = exports.isAbsolute(path);\n    // Split the path into parts between `/` characters. This is much faster than\n    // using `.split(/\\/+/g)`.\n    var parts = [];\n    var start = 0;\n    var i = 0;\n    while(true){\n        start = i;\n        i = path.indexOf(\"/\", start);\n        if (i === -1) {\n            parts.push(path.slice(start));\n            break;\n        } else {\n            parts.push(path.slice(start, i));\n            while(i < path.length && path[i] === \"/\"){\n                i++;\n            }\n        }\n    }\n    for(var part, up = 0, i = parts.length - 1; i >= 0; i--){\n        part = parts[i];\n        if (part === \".\") {\n            parts.splice(i, 1);\n        } else if (part === \"..\") {\n            up++;\n        } else if (up > 0) {\n            if (part === \"\") {\n                // The first part is blank if the path is absolute. Trying to go\n                // above the root is a no-op. Therefore we can remove all '..' parts\n                // directly after the root.\n                parts.splice(i + 1, up);\n                up = 0;\n            } else {\n                parts.splice(i, 2);\n                up--;\n            }\n        }\n    }\n    path = parts.join(\"/\");\n    if (path === \"\") {\n        path = isAbsolute ? \"/\" : \".\";\n    }\n    if (url) {\n        url.path = path;\n        return urlGenerate(url);\n    }\n    return path;\n});\nexports.normalize = normalize;\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */ function join(aRoot, aPath) {\n    if (aRoot === \"\") {\n        aRoot = \".\";\n    }\n    if (aPath === \"\") {\n        aPath = \".\";\n    }\n    var aPathUrl = urlParse(aPath);\n    var aRootUrl = urlParse(aRoot);\n    if (aRootUrl) {\n        aRoot = aRootUrl.path || \"/\";\n    }\n    // `join(foo, '//www.example.org')`\n    if (aPathUrl && !aPathUrl.scheme) {\n        if (aRootUrl) {\n            aPathUrl.scheme = aRootUrl.scheme;\n        }\n        return urlGenerate(aPathUrl);\n    }\n    if (aPathUrl || aPath.match(dataUrlRegexp)) {\n        return aPath;\n    }\n    // `join('http://', 'www.example.com')`\n    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n        aRootUrl.host = aPath;\n        return urlGenerate(aRootUrl);\n    }\n    var joined = aPath.charAt(0) === \"/\" ? aPath : normalize(aRoot.replace(/\\/+$/, \"\") + \"/\" + aPath);\n    if (aRootUrl) {\n        aRootUrl.path = joined;\n        return urlGenerate(aRootUrl);\n    }\n    return joined;\n}\nexports.join = join;\nexports.isAbsolute = function(aPath) {\n    return aPath.charAt(0) === \"/\" || urlRegexp.test(aPath);\n};\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */ function relative(aRoot, aPath) {\n    if (aRoot === \"\") {\n        aRoot = \".\";\n    }\n    aRoot = aRoot.replace(/\\/$/, \"\");\n    // It is possible for the path to be above the root. In this case, simply\n    // checking whether the root is a prefix of the path won't work. Instead, we\n    // need to remove components from the root one by one, until either we find\n    // a prefix that fits, or we run out of components to remove.\n    var level = 0;\n    while(aPath.indexOf(aRoot + \"/\") !== 0){\n        var index = aRoot.lastIndexOf(\"/\");\n        if (index < 0) {\n            return aPath;\n        }\n        // If the only part of the root that is left is the scheme (i.e. http://,\n        // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n        // have exhausted all components, so the path is not relative to the root.\n        aRoot = aRoot.slice(0, index);\n        if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n            return aPath;\n        }\n        ++level;\n    }\n    // Make sure we add a \"../\" for each component we removed from the root.\n    return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\nvar supportsNullProto = function() {\n    var obj = Object.create(null);\n    return !(\"__proto__\" in obj);\n}();\nfunction identity(s) {\n    return s;\n}\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */ function toSetString(aStr) {\n    if (isProtoString(aStr)) {\n        return \"$\" + aStr;\n    }\n    return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\nfunction fromSetString(aStr) {\n    if (isProtoString(aStr)) {\n        return aStr.slice(1);\n    }\n    return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\nfunction isProtoString(s) {\n    if (!s) {\n        return false;\n    }\n    var length = s.length;\n    if (length < 9 /* \"__proto__\".length */ ) {\n        return false;\n    }\n    if (s.charCodeAt(length - 1) !== 95 /* '_' */  || s.charCodeAt(length - 2) !== 95 /* '_' */  || s.charCodeAt(length - 3) !== 111 /* 'o' */  || s.charCodeAt(length - 4) !== 116 /* 't' */  || s.charCodeAt(length - 5) !== 111 /* 'o' */  || s.charCodeAt(length - 6) !== 114 /* 'r' */  || s.charCodeAt(length - 7) !== 112 /* 'p' */  || s.charCodeAt(length - 8) !== 95 /* '_' */  || s.charCodeAt(length - 9) !== 95 /* '_' */ ) {\n        return false;\n    }\n    for(var i = length - 10; i >= 0; i--){\n        if (s.charCodeAt(i) !== 36 /* '$' */ ) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */ function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n    var cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0 || onlyCompareOriginal) {\n        return cmp;\n    }\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\nfunction compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {\n    var cmp;\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0 || onlyCompareOriginal) {\n        return cmp;\n    }\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */ function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n    var cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0 || onlyCompareGenerated) {\n        return cmp;\n    }\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\nfunction compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {\n    var cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0 || onlyCompareGenerated) {\n        return cmp;\n    }\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;\nfunction strcmp(aStr1, aStr2) {\n    if (aStr1 === aStr2) {\n        return 0;\n    }\n    if (aStr1 === null) {\n        return 1; // aStr2 !== null\n    }\n    if (aStr2 === null) {\n        return -1; // aStr1 !== null\n    }\n    if (aStr1 > aStr2) {\n        return 1;\n    }\n    return -1;\n}\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */ function compareByGeneratedPositionsInflated(mappingA, mappingB) {\n    var cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */ function parseSourceMapInput(str) {\n    return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */ function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n    sourceURL = sourceURL || \"\";\n    if (sourceRoot) {\n        // This follows what Chrome does.\n        if (sourceRoot[sourceRoot.length - 1] !== \"/\" && sourceURL[0] !== \"/\") {\n            sourceRoot += \"/\";\n        }\n        // The spec says:\n        //   Line 4: An optional source root, useful for relocating source\n        //   files on a server or removing repeated values in the\n        //   “sources” entry.  This value is prepended to the individual\n        //   entries in the “source” field.\n        sourceURL = sourceRoot + sourceURL;\n    }\n    // Historically, SourceMapConsumer did not take the sourceMapURL as\n    // a parameter.  This mode is still somewhat supported, which is why\n    // this code block is conditional.  However, it's preferable to pass\n    // the source map URL to SourceMapConsumer, so that this function\n    // can implement the source URL resolution algorithm as outlined in\n    // the spec.  This block is basically the equivalent of:\n    //    new URL(sourceURL, sourceMapURL).toString()\n    // ... except it avoids using URL, which wasn't available in the\n    // older releases of node still supported by this library.\n    //\n    // The spec says:\n    //   If the sources are not absolute URLs after prepending of the\n    //   “sourceRoot”, the sources are resolved relative to the\n    //   SourceMap (like resolving script src in a html document).\n    if (sourceMapURL) {\n        var parsed = urlParse(sourceMapURL);\n        if (!parsed) {\n            throw new Error(\"sourceMapURL could not be parsed\");\n        }\n        if (parsed.path) {\n            // Strip the last path component, but keep the \"/\".\n            var index = parsed.path.lastIndexOf(\"/\");\n            if (index >= 0) {\n                parsed.path = parsed.path.substring(0, index + 1);\n            }\n        }\n        sourceURL = join(urlGenerate(parsed), sourceURL);\n    }\n    return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1qcy9saWIvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5Q0FBeUMsR0FDekM7Ozs7Q0FJQyxHQUVEOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNBLE9BQU9DLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxhQUFhO0lBQ3pDLElBQUlELFNBQVNELE9BQU87UUFDbEIsT0FBT0EsS0FBSyxDQUFDQyxNQUFNO0lBQ3JCLE9BQU8sSUFBSUUsVUFBVUMsTUFBTSxLQUFLLEdBQUc7UUFDakMsT0FBT0Y7SUFDVCxPQUFPO1FBQ0wsTUFBTSxJQUFJRyxNQUFNLE1BQU1KLFFBQVE7SUFDaEM7QUFDRjtBQUNBSyxjQUFjLEdBQUdQO0FBRWpCLElBQUlRLFlBQVk7QUFDaEIsSUFBSUMsZ0JBQWdCO0FBRXBCLFNBQVNDLFNBQVNDLElBQUk7SUFDcEIsSUFBSUMsUUFBUUQsS0FBS0MsS0FBSyxDQUFDSjtJQUN2QixJQUFJLENBQUNJLE9BQU87UUFDVixPQUFPO0lBQ1Q7SUFDQSxPQUFPO1FBQ0xDLFFBQVFELEtBQUssQ0FBQyxFQUFFO1FBQ2hCRSxNQUFNRixLQUFLLENBQUMsRUFBRTtRQUNkRyxNQUFNSCxLQUFLLENBQUMsRUFBRTtRQUNkSSxNQUFNSixLQUFLLENBQUMsRUFBRTtRQUNkSyxNQUFNTCxLQUFLLENBQUMsRUFBRTtJQUNoQjtBQUNGO0FBQ0FMLGdCQUFnQixHQUFHRztBQUVuQixTQUFTUSxZQUFZQyxVQUFVO0lBQzdCLElBQUlDLE1BQU07SUFDVixJQUFJRCxXQUFXTixNQUFNLEVBQUU7UUFDckJPLE9BQU9ELFdBQVdOLE1BQU0sR0FBRztJQUM3QjtJQUNBTyxPQUFPO0lBQ1AsSUFBSUQsV0FBV0wsSUFBSSxFQUFFO1FBQ25CTSxPQUFPRCxXQUFXTCxJQUFJLEdBQUc7SUFDM0I7SUFDQSxJQUFJSyxXQUFXSixJQUFJLEVBQUU7UUFDbkJLLE9BQU9ELFdBQVdKLElBQUk7SUFDeEI7SUFDQSxJQUFJSSxXQUFXSCxJQUFJ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ZGVfbW9kdWxlcy9zb3VyY2UtbWFwLWpzL2xpYi91dGlsLmpzP2M2NDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vKipcbiAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldHRpbmcgdmFsdWVzIGZyb20gcGFyYW1ldGVyL29wdGlvbnNcbiAqIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIGFyZ3MgVGhlIG9iamVjdCB3ZSBhcmUgZXh0cmFjdGluZyB2YWx1ZXMgZnJvbVxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdlIGFyZSBnZXR0aW5nLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAqIGZyb20gdGhlIG9iamVjdC4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgcHJvcGVydHkgaXMgbWlzc2luZywgYW5cbiAqIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICovXG5mdW5jdGlvbiBnZXRBcmcoYUFyZ3MsIGFOYW1lLCBhRGVmYXVsdFZhbHVlKSB7XG4gIGlmIChhTmFtZSBpbiBhQXJncykge1xuICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiBhRGVmYXVsdFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcbiAgfVxufVxuZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbnZhciB1cmxSZWdleHAgPSAvXig/OihbXFx3K1xcLS5dKyk6KT9cXC9cXC8oPzooXFx3KzpcXHcrKUApPyhbXFx3Li1dKikoPzo6KFxcZCspKT8oLiopJC87XG52YXIgZGF0YVVybFJlZ2V4cCA9IC9eZGF0YTouK1xcLC4rJC87XG5cbmZ1bmN0aW9uIHVybFBhcnNlKGFVcmwpIHtcbiAgdmFyIG1hdGNoID0gYVVybC5tYXRjaCh1cmxSZWdleHApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY2hlbWU6IG1hdGNoWzFdLFxuICAgIGF1dGg6IG1hdGNoWzJdLFxuICAgIGhvc3Q6IG1hdGNoWzNdLFxuICAgIHBvcnQ6IG1hdGNoWzRdLFxuICAgIHBhdGg6IG1hdGNoWzVdXG4gIH07XG59XG5leHBvcnRzLnVybFBhcnNlID0gdXJsUGFyc2U7XG5cbmZ1bmN0aW9uIHVybEdlbmVyYXRlKGFQYXJzZWRVcmwpIHtcbiAgdmFyIHVybCA9ICcnO1xuICBpZiAoYVBhcnNlZFVybC5zY2hlbWUpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5zY2hlbWUgKyAnOic7XG4gIH1cbiAgdXJsICs9ICcvLyc7XG4gIGlmIChhUGFyc2VkVXJsLmF1dGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5hdXRoICsgJ0AnO1xuICB9XG4gIGlmIChhUGFyc2VkVXJsLmhvc3QpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5ob3N0O1xuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBvcnQpIHtcbiAgICB1cmwgKz0gXCI6XCIgKyBhUGFyc2VkVXJsLnBvcnRcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5wYXRoKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwucGF0aDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZXhwb3J0cy51cmxHZW5lcmF0ZSA9IHVybEdlbmVyYXRlO1xuXG52YXIgTUFYX0NBQ0hFRF9JTlBVVFMgPSAzMjtcblxuLyoqXG4gKiBUYWtlcyBzb21lIGZ1bmN0aW9uIGBmKGlucHV0KSAtPiByZXN1bHRgIGFuZCByZXR1cm5zIGEgbWVtb2l6ZWQgdmVyc2lvbiBvZlxuICogYGZgLlxuICpcbiAqIFdlIGtlZXAgYXQgbW9zdCBgTUFYX0NBQ0hFRF9JTlBVVFNgIG1lbW9pemVkIHJlc3VsdHMgb2YgYGZgIGFsaXZlLiBUaGVcbiAqIG1lbW9pemF0aW9uIGlzIGEgZHVtYi1zaW1wbGUsIGxpbmVhciBsZWFzdC1yZWNlbnRseS11c2VkIGNhY2hlLlxuICovXG5mdW5jdGlvbiBscnVNZW1vaXplKGYpIHtcbiAgdmFyIGNhY2hlID0gW107XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNhY2hlW2ldLmlucHV0ID09PSBpbnB1dCkge1xuICAgICAgICB2YXIgdGVtcCA9IGNhY2hlWzBdO1xuICAgICAgICBjYWNoZVswXSA9IGNhY2hlW2ldO1xuICAgICAgICBjYWNoZVtpXSA9IHRlbXA7XG4gICAgICAgIHJldHVybiBjYWNoZVswXS5yZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IGYoaW5wdXQpO1xuXG4gICAgY2FjaGUudW5zaGlmdCh7XG4gICAgICBpbnB1dCxcbiAgICAgIHJlc3VsdCxcbiAgICB9KTtcblxuICAgIGlmIChjYWNoZS5sZW5ndGggPiBNQVhfQ0FDSEVEX0lOUFVUUykge1xuICAgICAgY2FjaGUucG9wKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgcGF0aCwgb3IgdGhlIHBhdGggcG9ydGlvbiBvZiBhIFVSTDpcbiAqXG4gKiAtIFJlcGxhY2VzIGNvbnNlY3V0aXZlIHNsYXNoZXMgd2l0aCBvbmUgc2xhc2guXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJy4nIHBhcnRzLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICc8ZGlyPi8uLicgcGFydHMuXG4gKlxuICogQmFzZWQgb24gY29kZSBpbiB0aGUgTm9kZS5qcyAncGF0aCcgY29yZSBtb2R1bGUuXG4gKlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIHVybCB0byBub3JtYWxpemUuXG4gKi9cbnZhciBub3JtYWxpemUgPSBscnVNZW1vaXplKGZ1bmN0aW9uIG5vcm1hbGl6ZShhUGF0aCkge1xuICB2YXIgcGF0aCA9IGFQYXRoO1xuICB2YXIgdXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICBpZiAodXJsKSB7XG4gICAgaWYgKCF1cmwucGF0aCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cbiAgICBwYXRoID0gdXJsLnBhdGg7XG4gIH1cbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCk7XG4gIC8vIFNwbGl0IHRoZSBwYXRoIGludG8gcGFydHMgYmV0d2VlbiBgL2AgY2hhcmFjdGVycy4gVGhpcyBpcyBtdWNoIGZhc3RlciB0aGFuXG4gIC8vIHVzaW5nIGAuc3BsaXQoL1xcLysvZylgLlxuICB2YXIgcGFydHMgPSBbXTtcbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN0YXJ0ID0gaTtcbiAgICBpID0gcGF0aC5pbmRleE9mKFwiL1wiLCBzdGFydCk7XG4gICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICBwYXJ0cy5wdXNoKHBhdGguc2xpY2Uoc3RhcnQpKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0cy5wdXNoKHBhdGguc2xpY2Uoc3RhcnQsIGkpKTtcbiAgICAgIHdoaWxlIChpIDwgcGF0aC5sZW5ndGggJiYgcGF0aFtpXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIHBhcnQsIHVwID0gMCwgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgcGFydCA9IHBhcnRzW2ldO1xuICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCA+IDApIHtcbiAgICAgIGlmIChwYXJ0ID09PSAnJykge1xuICAgICAgICAvLyBUaGUgZmlyc3QgcGFydCBpcyBibGFuayBpZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZS4gVHJ5aW5nIHRvIGdvXG4gICAgICAgIC8vIGFib3ZlIHRoZSByb290IGlzIGEgbm8tb3AuIFRoZXJlZm9yZSB3ZSBjYW4gcmVtb3ZlIGFsbCAnLi4nIHBhcnRzXG4gICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIHRoZSByb290LlxuICAgICAgICBwYXJ0cy5zcGxpY2UoaSArIDEsIHVwKTtcbiAgICAgICAgdXAgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMuc3BsaWNlKGksIDIpO1xuICAgICAgICB1cC0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXRoID0gcGFydHMuam9pbignLycpO1xuXG4gIGlmIChwYXRoID09PSAnJykge1xuICAgIHBhdGggPSBpc0Fic29sdXRlID8gJy8nIDogJy4nO1xuICB9XG5cbiAgaWYgKHVybCkge1xuICAgIHVybC5wYXRoID0gcGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUodXJsKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn0pO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbi8qKlxuICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAqXG4gKiAtIElmIGFQYXRoIGlzIGEgVVJMIG9yIGEgZGF0YSBVUkksIGFQYXRoIGlzIHJldHVybmVkLCB1bmxlc3MgYVBhdGggaXMgYVxuICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gKiAgIGZpcnN0LlxuICogLSBPdGhlcndpc2UgYVBhdGggaXMgYSBwYXRoLiBJZiBhUm9vdCBpcyBhIFVSTCwgdGhlbiBpdHMgcGF0aCBwb3J0aW9uXG4gKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAqICAgaXMgcmV0dXJuZWQuXG4gKiAgIC0gSWYgYVBhdGggaXMgYWJzb2x1dGUsIHRoZSByZXN1bHQgaXMgYVBhdGguXG4gKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gKiAtIEpvaW5pbmcgZm9yIGV4YW1wbGUgJ2h0dHA6Ly8nIGFuZCAnd3d3LmV4YW1wbGUuY29tJyBpcyBhbHNvIHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuICBpZiAoYVBhdGggPT09IFwiXCIpIHtcbiAgICBhUGF0aCA9IFwiLlwiO1xuICB9XG4gIHZhciBhUGF0aFVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgdmFyIGFSb290VXJsID0gdXJsUGFyc2UoYVJvb3QpO1xuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdCA9IGFSb290VXJsLnBhdGggfHwgJy8nO1xuICB9XG5cbiAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgaWYgKGFQYXRoVXJsICYmICFhUGF0aFVybC5zY2hlbWUpIHtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICB9XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFQYXRoVXJsKTtcbiAgfVxuXG4gIGlmIChhUGF0aFVybCB8fCBhUGF0aC5tYXRjaChkYXRhVXJsUmVnZXhwKSkge1xuICAgIHJldHVybiBhUGF0aDtcbiAgfVxuXG4gIC8vIGBqb2luKCdodHRwOi8vJywgJ3d3dy5leGFtcGxlLmNvbScpYFxuICBpZiAoYVJvb3RVcmwgJiYgIWFSb290VXJsLmhvc3QgJiYgIWFSb290VXJsLnBhdGgpIHtcbiAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuXG4gIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgID8gYVBhdGhcbiAgICA6IG5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIGFQYXRoKTtcblxuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdFVybC5wYXRoID0gam9pbmVkO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cbiAgcmV0dXJuIGpvaW5lZDtcbn1cbmV4cG9ydHMuam9pbiA9IGpvaW47XG5cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uIChhUGF0aCkge1xuICByZXR1cm4gYVBhdGguY2hhckF0KDApID09PSAnLycgfHwgdXJsUmVnZXhwLnRlc3QoYVBhdGgpO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgcGF0aCByZWxhdGl2ZSB0byBhIFVSTCBvciBhbm90aGVyIHBhdGguXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBtYWRlIHJlbGF0aXZlIHRvIGFSb290LlxuICovXG5mdW5jdGlvbiByZWxhdGl2ZShhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuXG4gIGFSb290ID0gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhdGggdG8gYmUgYWJvdmUgdGhlIHJvb3QuIEluIHRoaXMgY2FzZSwgc2ltcGx5XG4gIC8vIGNoZWNraW5nIHdoZXRoZXIgdGhlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlIHBhdGggd29uJ3Qgd29yay4gSW5zdGVhZCwgd2VcbiAgLy8gbmVlZCB0byByZW1vdmUgY29tcG9uZW50cyBmcm9tIHRoZSByb290IG9uZSBieSBvbmUsIHVudGlsIGVpdGhlciB3ZSBmaW5kXG4gIC8vIGEgcHJlZml4IHRoYXQgZml0cywgb3Igd2UgcnVuIG91dCBvZiBjb21wb25lbnRzIHRvIHJlbW92ZS5cbiAgdmFyIGxldmVsID0gMDtcbiAgd2hpbGUgKGFQYXRoLmluZGV4T2YoYVJvb3QgKyAnLycpICE9PSAwKSB7XG4gICAgdmFyIGluZGV4ID0gYVJvb3QubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgb25seSBwYXJ0IG9mIHRoZSByb290IHRoYXQgaXMgbGVmdCBpcyB0aGUgc2NoZW1lIChpLmUuIGh0dHA6Ly8sXG4gICAgLy8gZmlsZTovLy8sIGV0Yy4pLCBvbmUgb3IgbW9yZSBzbGFzaGVzICgvKSwgb3Igc2ltcGx5IG5vdGhpbmcgYXQgYWxsLCB3ZVxuICAgIC8vIGhhdmUgZXhoYXVzdGVkIGFsbCBjb21wb25lbnRzLCBzbyB0aGUgcGF0aCBpcyBub3QgcmVsYXRpdmUgdG8gdGhlIHJvb3QuXG4gICAgYVJvb3QgPSBhUm9vdC5zbGljZSgwLCBpbmRleCk7XG4gICAgaWYgKGFSb290Lm1hdGNoKC9eKFteXFwvXSs6XFwvKT9cXC8qJC8pKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgKytsZXZlbDtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBhZGQgYSBcIi4uL1wiIGZvciBlYWNoIGNvbXBvbmVudCB3ZSByZW1vdmVkIGZyb20gdGhlIHJvb3QuXG4gIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4oXCIuLi9cIikgKyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSk7XG59XG5leHBvcnRzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG5cbnZhciBzdXBwb3J0c051bGxQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gISgnX19wcm90b19fJyBpbiBvYmopO1xufSgpKTtcblxuZnVuY3Rpb24gaWRlbnRpdHkgKHMpIHtcbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogQmVjYXVzZSBiZWhhdmlvciBnb2VzIHdhY2t5IHdoZW4geW91IHNldCBgX19wcm90b19fYCBvbiBvYmplY3RzLCB3ZVxuICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL3B1bGwvMzEgYW5kXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5mdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMudG9TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogdG9TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiBhU3RyLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLmZyb21TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogZnJvbVNldFN0cmluZztcblxuZnVuY3Rpb24gaXNQcm90b1N0cmluZyhzKSB7XG4gIGlmICghcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBzLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgOSAvKiBcIl9fcHJvdG9fX1wiLmxlbmd0aCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMSkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAyKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDMpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNCkgIT09IDExNiAvKiAndCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA1KSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDYpICE9PSAxMTQgLyogJ3InICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNykgIT09IDExMiAvKiAncCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA4KSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDkpICE9PSA5NSAgLyogJ18nICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDEwOyBpID49IDA7IGktLSkge1xuICAgIGlmIChzLmNoYXJDb2RlQXQoaSkgIT09IDM2IC8qICckJyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4sIGJ1dCBkaWZmZXJlbnQgZ2VuZXJhdGVkXG4gKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICogc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gIHZhciBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbmZ1bmN0aW9uIGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zTm9Tb3VyY2UobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gIHZhciBjbXBcblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9uc05vU291cmNlID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnNOb1NvdXJjZTtcblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggZGVmbGF0ZWQgc291cmNlIGFuZCBuYW1lIGluZGljZXMgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4sIGJ1dCBkaWZmZXJlbnRcbiAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gKiBtYXBwaW5nIHdpdGggYSBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkO1xuXG5mdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZE5vTGluZShtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZE5vTGluZSA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkTm9MaW5lO1xuXG5mdW5jdGlvbiBzdHJjbXAoYVN0cjEsIGFTdHIyKSB7XG4gIGlmIChhU3RyMSA9PT0gYVN0cjIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChhU3RyMSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAxOyAvLyBhU3RyMiAhPT0gbnVsbFxuICB9XG5cbiAgaWYgKGFTdHIyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xOyAvLyBhU3RyMSAhPT0gbnVsbFxuICB9XG5cbiAgaWYgKGFTdHIxID4gYVN0cjIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggaW5mbGF0ZWQgc291cmNlIGFuZCBuYW1lIHN0cmluZ3Mgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkO1xuXG4vKipcbiAqIFN0cmlwIGFueSBKU09OIFhTU0kgYXZvaWRhbmNlIHByZWZpeCBmcm9tIHRoZSBzdHJpbmcgKGFzIGRvY3VtZW50ZWRcbiAqIGluIHRoZSBzb3VyY2UgbWFwcyBzcGVjaWZpY2F0aW9uKSwgYW5kIHRoZW4gcGFyc2UgdGhlIHN0cmluZyBhc1xuICogSlNPTi5cbiAqL1xuZnVuY3Rpb24gcGFyc2VTb3VyY2VNYXBJbnB1dChzdHIpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyLnJlcGxhY2UoL15cXCldfSdbXlxcbl0qXFxuLywgJycpKTtcbn1cbmV4cG9ydHMucGFyc2VTb3VyY2VNYXBJbnB1dCA9IHBhcnNlU291cmNlTWFwSW5wdXQ7XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgVVJMIG9mIGEgc291cmNlIGdpdmVuIHRoZSB0aGUgc291cmNlIHJvb3QsIHRoZSBzb3VyY2Unc1xuICogVVJMLCBhbmQgdGhlIHNvdXJjZSBtYXAncyBVUkwuXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgc291cmNlVVJMLCBzb3VyY2VNYXBVUkwpIHtcbiAgc291cmNlVVJMID0gc291cmNlVVJMIHx8ICcnO1xuXG4gIGlmIChzb3VyY2VSb290KSB7XG4gICAgLy8gVGhpcyBmb2xsb3dzIHdoYXQgQ2hyb21lIGRvZXMuXG4gICAgaWYgKHNvdXJjZVJvb3Rbc291cmNlUm9vdC5sZW5ndGggLSAxXSAhPT0gJy8nICYmIHNvdXJjZVVSTFswXSAhPT0gJy8nKSB7XG4gICAgICBzb3VyY2VSb290ICs9ICcvJztcbiAgICB9XG4gICAgLy8gVGhlIHNwZWMgc2F5czpcbiAgICAvLyAgIExpbmUgNDogQW4gb3B0aW9uYWwgc291cmNlIHJvb3QsIHVzZWZ1bCBmb3IgcmVsb2NhdGluZyBzb3VyY2VcbiAgICAvLyAgIGZpbGVzIG9uIGEgc2VydmVyIG9yIHJlbW92aW5nIHJlcGVhdGVkIHZhbHVlcyBpbiB0aGVcbiAgICAvLyAgIOKAnHNvdXJjZXPigJ0gZW50cnkuICBUaGlzIHZhbHVlIGlzIHByZXBlbmRlZCB0byB0aGUgaW5kaXZpZHVhbFxuICAgIC8vICAgZW50cmllcyBpbiB0aGUg4oCcc291cmNl4oCdIGZpZWxkLlxuICAgIHNvdXJjZVVSTCA9IHNvdXJjZVJvb3QgKyBzb3VyY2VVUkw7XG4gIH1cblxuICAvLyBIaXN0b3JpY2FsbHksIFNvdXJjZU1hcENvbnN1bWVyIGRpZCBub3QgdGFrZSB0aGUgc291cmNlTWFwVVJMIGFzXG4gIC8vIGEgcGFyYW1ldGVyLiAgVGhpcyBtb2RlIGlzIHN0aWxsIHNvbWV3aGF0IHN1cHBvcnRlZCwgd2hpY2ggaXMgd2h5XG4gIC8vIHRoaXMgY29kZSBibG9jayBpcyBjb25kaXRpb25hbC4gIEhvd2V2ZXIsIGl0J3MgcHJlZmVyYWJsZSB0byBwYXNzXG4gIC8vIHRoZSBzb3VyY2UgbWFwIFVSTCB0byBTb3VyY2VNYXBDb25zdW1lciwgc28gdGhhdCB0aGlzIGZ1bmN0aW9uXG4gIC8vIGNhbiBpbXBsZW1lbnQgdGhlIHNvdXJjZSBVUkwgcmVzb2x1dGlvbiBhbGdvcml0aG0gYXMgb3V0bGluZWQgaW5cbiAgLy8gdGhlIHNwZWMuICBUaGlzIGJsb2NrIGlzIGJhc2ljYWxseSB0aGUgZXF1aXZhbGVudCBvZjpcbiAgLy8gICAgbmV3IFVSTChzb3VyY2VVUkwsIHNvdXJjZU1hcFVSTCkudG9TdHJpbmcoKVxuICAvLyAuLi4gZXhjZXB0IGl0IGF2b2lkcyB1c2luZyBVUkwsIHdoaWNoIHdhc24ndCBhdmFpbGFibGUgaW4gdGhlXG4gIC8vIG9sZGVyIHJlbGVhc2VzIG9mIG5vZGUgc3RpbGwgc3VwcG9ydGVkIGJ5IHRoaXMgbGlicmFyeS5cbiAgLy9cbiAgLy8gVGhlIHNwZWMgc2F5czpcbiAgLy8gICBJZiB0aGUgc291cmNlcyBhcmUgbm90IGFic29sdXRlIFVSTHMgYWZ0ZXIgcHJlcGVuZGluZyBvZiB0aGVcbiAgLy8gICDigJxzb3VyY2VSb2904oCdLCB0aGUgc291cmNlcyBhcmUgcmVzb2x2ZWQgcmVsYXRpdmUgdG8gdGhlXG4gIC8vICAgU291cmNlTWFwIChsaWtlIHJlc29sdmluZyBzY3JpcHQgc3JjIGluIGEgaHRtbCBkb2N1bWVudCkuXG4gIGlmIChzb3VyY2VNYXBVUkwpIHtcbiAgICB2YXIgcGFyc2VkID0gdXJsUGFyc2Uoc291cmNlTWFwVVJMKTtcbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic291cmNlTWFwVVJMIGNvdWxkIG5vdCBiZSBwYXJzZWRcIik7XG4gICAgfVxuICAgIGlmIChwYXJzZWQucGF0aCkge1xuICAgICAgLy8gU3RyaXAgdGhlIGxhc3QgcGF0aCBjb21wb25lbnQsIGJ1dCBrZWVwIHRoZSBcIi9cIi5cbiAgICAgIHZhciBpbmRleCA9IHBhcnNlZC5wYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBwYXJzZWQucGF0aCA9IHBhcnNlZC5wYXRoLnN1YnN0cmluZygwLCBpbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2VVUkwgPSBqb2luKHVybEdlbmVyYXRlKHBhcnNlZCksIHNvdXJjZVVSTCk7XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplKHNvdXJjZVVSTCk7XG59XG5leHBvcnRzLmNvbXB1dGVTb3VyY2VVUkwgPSBjb21wdXRlU291cmNlVVJMO1xuIl0sIm5hbWVzIjpbImdldEFyZyIsImFBcmdzIiwiYU5hbWUiLCJhRGVmYXVsdFZhbHVlIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiRXJyb3IiLCJleHBvcnRzIiwidXJsUmVnZXhwIiwiZGF0YVVybFJlZ2V4cCIsInVybFBhcnNlIiwiYVVybCIsIm1hdGNoIiwic2NoZW1lIiwiYXV0aCIsImhvc3QiLCJwb3J0IiwicGF0aCIsInVybEdlbmVyYXRlIiwiYVBhcnNlZFVybCIsInVybCIsIk1BWF9DQUNIRURfSU5QVVRTIiwibHJ1TWVtb2l6ZSIsImYiLCJjYWNoZSIsImlucHV0IiwiaSIsInRlbXAiLCJyZXN1bHQiLCJ1bnNoaWZ0IiwicG9wIiwibm9ybWFsaXplIiwiYVBhdGgiLCJpc0Fic29sdXRlIiwicGFydHMiLCJzdGFydCIsImluZGV4T2YiLCJwdXNoIiwic2xpY2UiLCJwYXJ0IiwidXAiLCJzcGxpY2UiLCJqb2luIiwiYVJvb3QiLCJhUGF0aFVybCIsImFSb290VXJsIiwiam9pbmVkIiwiY2hhckF0IiwicmVwbGFjZSIsInRlc3QiLCJyZWxhdGl2ZSIsImxldmVsIiwiaW5kZXgiLCJsYXN0SW5kZXhPZiIsIkFycmF5Iiwic3Vic3RyIiwic3VwcG9ydHNOdWxsUHJvdG8iLCJvYmoiLCJPYmplY3QiLCJjcmVhdGUiLCJpZGVudGl0eSIsInMiLCJ0b1NldFN0cmluZyIsImFTdHIiLCJpc1Byb3RvU3RyaW5nIiwiZnJvbVNldFN0cmluZyIsImNoYXJDb2RlQXQiLCJjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyIsIm1hcHBpbmdBIiwibWFwcGluZ0IiLCJvbmx5Q29tcGFyZU9yaWdpbmFsIiwiY21wIiwic3RyY21wIiwic291cmNlIiwib3JpZ2luYWxMaW5lIiwib3JpZ2luYWxDb2x1bW4iLCJnZW5lcmF0ZWRDb2x1bW4iLCJnZW5lcmF0ZWRMaW5lIiwibmFtZSIsImNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zTm9Tb3VyY2UiLCJjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCIsIm9ubHlDb21wYXJlR2VuZXJhdGVkIiwiY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWROb0xpbmUiLCJhU3RyMSIsImFTdHIyIiwiY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQiLCJwYXJzZVNvdXJjZU1hcElucHV0Iiwic3RyIiwiSlNPTiIsInBhcnNlIiwiY29tcHV0ZVNvdXJjZVVSTCIsInNvdXJjZVJvb3QiLCJzb3VyY2VVUkwiLCJzb3VyY2VNYXBVUkwiLCJwYXJzZWQiLCJzdWJzdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/source-map-js/lib/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/source-map-js/source-map.js":
/*!**************************************************!*\
  !*** ./node_modules/source-map-js/source-map.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ exports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ \"(ssr)/./node_modules/source-map-js/lib/source-map-generator.js\").SourceMapGenerator;\nexports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ \"(ssr)/./node_modules/source-map-js/lib/source-map-consumer.js\").SourceMapConsumer;\nexports.SourceNode = __webpack_require__(/*! ./lib/source-node */ \"(ssr)/./node_modules/source-map-js/lib/source-node.js\").SourceNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1qcy9zb3VyY2UtbWFwLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUMsR0FDREEsdUtBQXFGO0FBQ3JGQSxtS0FBa0Y7QUFDbEZBLHFJQUE0RCIsInNvdXJjZXMiOlsid2VicGFjazovL3dvcmtmbG93Ly4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtanMvc291cmNlLW1hcC5qcz81NDJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRS50eHQgb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1jb25zdW1lcicpLlNvdXJjZU1hcENvbnN1bWVyO1xuZXhwb3J0cy5Tb3VyY2VOb2RlID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW5vZGUnKS5Tb3VyY2VOb2RlO1xuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJTb3VyY2VNYXBHZW5lcmF0b3IiLCJyZXF1aXJlIiwiU291cmNlTWFwQ29uc3VtZXIiLCJTb3VyY2VOb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/source-map-js/source-map.js\n");

/***/ })

};
;